<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Jouyouyun&#39;s Blog</title>
    <link>http://45.62.229.81:8080</link>
    <pubDate>02 Dec 18 23:12 CST</pubDate>
    <item>
      <title>python3 学习笔记</title>
      <link>http://45.62.229.81:8080/Blog/python3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2018-12-02 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Python3 Study Notes&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;本人很少写 &lt;code&gt;python&lt;/code&gt; 代码, 一般都是用 &lt;code&gt;go&lt;/code&gt; 的, 去年时用 &lt;code&gt;python&lt;/code&gt; 写过一些收集系统信息的工具, 当时是边看手册边写的. 如今又要用 &lt;code&gt;python&lt;/code&gt; 来写一个生成 &lt;code&gt;xlsx&lt;/code&gt; 的工具, 就又需要查看手册了, 至于为什么不用 &lt;code&gt;go&lt;/code&gt; 写? 那是因为 &lt;code&gt;go&lt;/code&gt; 的库不兼容永中. 在这里不得不说, 虽然 &lt;code&gt;go&lt;/code&gt; 很火, 但是一些库还是不如 &lt;code&gt;python&lt;/code&gt; 多, 不如 &lt;code&gt;python&lt;/code&gt; 兼容性好.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了避免以后再出这种事情, 这次就好好的了解下 &lt;code&gt;python&lt;/code&gt;, 将它的用法按照自己对语言的理解分块记录下来. 要使用某种语言, 个人认为需要了解这些方面:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编码风格&lt;/li&gt;&#xA;&lt;li&gt;变量的类型, 声明及使用方式&lt;/li&gt;&#xA;&lt;li&gt;输入/输出&lt;/li&gt;&#xA;&lt;li&gt;控制语句的写法&lt;/li&gt;&#xA;&lt;li&gt;错误处理的用法&lt;/li&gt;&#xA;&lt;li&gt;函数的用法, 还有语言支持的一些特性, &lt;code&gt;python&lt;/code&gt; 中就有装饰器, &lt;code&gt;lambda&lt;/code&gt; 语句等&lt;/li&gt;&#xA;&lt;li&gt;对于面向对象语言还需要了解类的声明, 继承, 多态等的用法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;还有一些就是此语言的一些特性, &lt;code&gt;python&lt;/code&gt; 就还需要了解以下特性:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模块的使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;下文就将按照这些内容来一一记录.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;编码风格&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;变量名, 方法名和模块名建议小写, 单词以 &lt;code&gt;_&lt;/code&gt; 分割, 类名建议驼峰命名风格, 首字母大写, 私有类可用一个 &lt;code&gt;_&lt;/code&gt; 开头.&lt;/li&gt;&#xA;&lt;li&gt;每行结尾尽量不要添加 &lt;code&gt;;&lt;/code&gt;, 多行代码也不要写在一行&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;python&lt;/code&gt; 是以缩进来控制代码段的, 所以缩减建议使用 4 个空格&lt;/li&gt;&#xA;&lt;li&gt;编码尽量使用 &lt;code&gt;utf-8&lt;/code&gt;, &lt;code&gt;python&lt;/code&gt; 默认使用 &lt;code&gt;ASCII&lt;/code&gt;, 所以要在文件的开头添加 &lt;code&gt;# -*- coding: UTF-8 -*-&lt;/code&gt; 或者 &lt;code&gt;#coding=utf-8&lt;/code&gt; 来指定&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;python&lt;/code&gt; 有独一无二的注释方式: 文档字符串, 所以注释尽量用文档字符串(&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;xxxx&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;如果一个类不从其他类继承, 就显示的从 &lt;code&gt;object&lt;/code&gt; 类继承&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;with&lt;/code&gt; 语句来管理文件, 如 &lt;code&gt;open&lt;/code&gt; 或 &lt;code&gt;close&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;添加 &lt;code&gt;TODO&lt;/code&gt; 时, 尽量在其后紧跟 &lt;code&gt;()&lt;/code&gt;, 在里面写明作者名或 &lt;code&gt;email&lt;/code&gt; 等其他标识信息, 然后紧跟一个 &lt;code&gt;:&lt;/code&gt; 后面接着写要做的事情&lt;/li&gt;&#xA;&lt;li&gt;每个导入模块都占一行, 不要一行导入多个模块&lt;/li&gt;&#xA;&lt;li&gt;尽量定义一个 &lt;code&gt;main&lt;/code&gt; 函数, 将主程序放入其中, 并在 &amp;ldquo;if &lt;span class=&#34;underline&#34;&gt;&lt;span class=&#34;underline&#34;&gt;name&lt;/span&gt;&lt;/span&gt; &lt;code&gt;= &#39;__main__&#39;:&amp;quot; 成立时执行 =main&lt;/code&gt;, 这样被当作模块导入时就不会执行主程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;变量&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Python&lt;/code&gt; 是动态语言, 变量的类型不固定, 根据值的类型而决定, 所以不用显示的声明变量， 用的时候直接赋值即可，如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = 1; // 此时是整型&#xA;print(a);&#xA;a = &#39;hello&#39;; // 此时又为字符串类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通常变量名全部大写的为 &lt;strong&gt;常量&lt;/strong&gt;, &lt;strong&gt;空值&lt;/strong&gt; 用 &lt;code&gt;None&lt;/code&gt; 表示.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以 &lt;code&gt;_xxx&lt;/code&gt; 或 &lt;code&gt;__xxx&lt;/code&gt; 命名的函数或变量是私有变量, 不能被其他模块直接引用&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;基础类型&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这里将整型, 浮点型, 布尔和字符串看作是基本类型, 整型和浮点型的使用就不再介绍了, 布尔的值只能为 &lt;code&gt;True/False&lt;/code&gt;, 而字符串的常见操作如下:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt; 或 &lt;code&gt;&#39;&#39;&#39;&lt;/code&gt; 可以嵌入长字符串&lt;/li&gt;&#xA;&lt;li&gt;字符串可以通过下标来索引, &lt;code&gt;len&lt;/code&gt; 函数获取长度&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;+&lt;/code&gt; 进行拼接操作&lt;/li&gt;&#xA;&lt;li&gt;字符串对象还内置了很多方法提供了一些常见功能, 具体请查阅手册&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;另外它们之间的相互转换是通过 &lt;code&gt;int(arg), float(arg), str(arg)&lt;/code&gt; 这些内置的方法来处理的.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;列表&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;列表中可以包含不同类型的数据, 如:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list = [&amp;quot;eggs&amp;quot;, 1, 67.12];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过 &lt;code&gt;list(seq)&lt;/code&gt; 可以将一个序列转换为列表.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;array&lt;/strong&gt; 模块提供了固定类型的数据, 可以指定要转换的类型, 具体请查阅手册.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;列表通过下标索引, &lt;code&gt;len&lt;/code&gt; 函数获取大小.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;列表对象常用的方法如下:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;append(item):&lt;/strong&gt; 附加元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;insert(idx, item):&lt;/strong&gt; 插入元素&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop(idx):&lt;/strong&gt; 删除指定位置的元素, 参数为空则删除最后一个元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;列表遍历:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for &amp;lt;variable&amp;gt; in &amp;lt;array&amp;gt;:&#xA;    // do&#xA;&#xA;// 带下标&#xA;for idx, name in enumerate(&amp;lt;array&amp;gt;):&#xA;    // do&#xA;&#xA;// 列表中多个元素&#xA;for x, y in [(1, 1), (2, 4), (3, 9)]:&#xA;    // do&#xA;&#xA;// 用 zip 同时遍历多个数组&#xA;a = [1, 2];&#xA;b = [5, 6];&#xA;for av, bv in zip(a, b):&#xA;    // do av=1, bv=5&#xA;&#xA;// 生成&#xA;[x * x for x in range(1, 11) if x % 2 == 0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;元组&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;元组(tuple) 是一个不可修改的列表, 元组中每个元素的指向是不可更改的, 但指向里的内容是可以更改的, 如元组中包含一个数组:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;t = (&#39;1&#39;, 1, [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;]);&#xA;t[2][0] = &amp;quot;X&amp;quot;;&#xA;t[2][1] = &amp;quot;Y&amp;quot;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;字典&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;语法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dict = {&#39;&amp;lt;key&amp;gt;&#39;:&amp;lt;value&amp;gt;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;常用的对象方法:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;get(key, value):&lt;/strong&gt; 获取指定 &lt;code&gt;key&lt;/code&gt; 的值, 如果不存在则返回 &lt;code&gt;value&lt;/code&gt;, 如果 &lt;code&gt;value&lt;/code&gt; 未指定则返回 &lt;code&gt;None&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pop(key):&lt;/strong&gt; 删除指定的 &lt;code&gt;key&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;使用字典需要注意以下几点:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;字典中的 &lt;code&gt;key&lt;/code&gt; 不能重复&lt;/li&gt;&#xA;&lt;li&gt;字典中的 &lt;code&gt;key&lt;/code&gt; 不可变, 所以只能用数字, 字符串和元组&lt;/li&gt;&#xA;&lt;li&gt;字典的值则没有限制, 可以是任意对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;集合&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;集合与字典类似, 是一组 &lt;code&gt;key&lt;/code&gt; 的集合, 但不存储 &lt;code&gt;value&lt;/code&gt;, 没有重复的 &lt;code&gt;key&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;要创建一个集合, 需要传入一个数组, 重复的元素会被自动过滤.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;遍历:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for &amp;lt;key&amp;gt; in &amp;lt;dict&amp;gt;:&#xA;    // do&#xA;&#xA;// 带下标&#xA;for idx, name in dict.items():&#xA;    // do&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s = set([1, 2, 3 ,3]); // s: {1,2,3}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;常用的对象方法:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;add(key):&lt;/strong&gt; 添加 &lt;code&gt;key&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;remove(key):&lt;/strong&gt; 删除 &lt;code&gt;key&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;global 关键字&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;global&lt;/code&gt; 关键字用于声明变量的作用域, 用法如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 全局变量&#xA;a = 1&#xA;&#xA;def test():&#xA;    # 若下面这行注释掉, 则下面的 a 是局部变量, &#39;Global&#39; 处的输出还是全局变量 1&#xA;    # 若下面这行取消注释, 则下面的 a 是全局变量, &#39;Gloabl&#39; 出的输出是 5&#xA;    # global a&#xA;    a = 5&#xA;    print(&amp;quot;In test:&amp;quot;, a)&#xA;&#xA;# Global&#xA;print(&amp;quot;Global:&amp;quot;, a)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出, &lt;code&gt;global a&lt;/code&gt; 注释掉时:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In test: 5&#xA;Global: 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出, &lt;code&gt;global a&lt;/code&gt; 取消注释时:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In test: 5&#xA;Global: 5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;更多&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;上面的只是基础，想要更好的使用变量，还需要了解以下内容：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;类型对象的方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 中每种类型都是对象, 都提供了一些内置方法, 如字符串类型的 &lt;code&gt;replace()&lt;/code&gt; 等&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;变量的内存分配&lt;/p&gt;&#xA;&#xA;&lt;p&gt;变量只是值的引用, 具体的内存分配是在值的这一边, 有些类型的值是不可变的, 这些是需要深入了解的&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;结构体&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 中没有结构体, 可以使用下列方式实现:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;struct&lt;/code&gt; 模块来实现, 需要了解与 &lt;code&gt;c&lt;/code&gt; 中类型的格式对照, 创建时需要指定结构体的成员类型&lt;/li&gt;&#xA;&lt;li&gt;使用类来实现, 在类的构造函数 &lt;code&gt;__init__&lt;/code&gt; 中定义结构体成员&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;输入/输出&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;输入&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;raw_input(prompt)&lt;/code&gt; 可以接受控制台的输入&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;输出&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;print()&lt;/code&gt; 可以打印内容到控制台, 格式化输出:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = 1;&#xA;s = &amp;quot;Joy&amp;quot;;&#xA;print(&amp;quot;The %d student&#39;s name is %s&amp;quot; % (n, s));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也可以使用 &lt;code&gt;format&lt;/code&gt; 来格式化, 它会用传入的参数依次替换字符串内的占位符 {0}、{1}…… :&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;// {3:.1f} 表示保留一位小数&#xA;s = &amp;quot;The {0} student&#39;s name is {1}, score: {3:.1f}&amp;quot;.format(1, &amp;quot;Joy&amp;quot;, 87.75);&#xA;print(s);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;控制语句&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;控制语句中可以使用 &lt;code&gt;break, continue, pass&lt;/code&gt; 关键字, &lt;code&gt;break&lt;/code&gt; 与 &lt;code&gt;continue&lt;/code&gt; 的作用与其他语言中的一样, &lt;code&gt;pass&lt;/code&gt; 则是一个空语句, 不做任何事情, 一般是为了保持结构的完整性, 常被用来占位, 表明之后会实现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; &lt;code&gt;python&lt;/code&gt; 中没有 &lt;code&gt;goto&lt;/code&gt; 和 &lt;code&gt;switch&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;IF&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;语法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if &amp;lt;condition&amp;gt;:&#xA;elif &amp;lt;condition&amp;gt;:&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;FOR&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for &amp;lt;variable&amp;gt; in &amp;lt;array&amp;gt;:&#xA;    // do&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;else&lt;/code&gt; 可选&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;WHILE&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;while &amp;lt;condition&amp;gt;:&#xA;    // do&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;else&lt;/code&gt; 可选&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;错误处理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;语法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:&#xA;    // do&#xA;except &amp;lt;error type&amp;gt; as e:&#xA;   // do&#xA;except &amp;lt;error type&amp;gt; as e:&#xA;else:&#xA;   // no error&#xA;finally:&#xA;   // do&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果 &lt;code&gt;finally&lt;/code&gt; 存在, 则无论有没有异常都会执行, &lt;code&gt;else&lt;/code&gt; 则在 &lt;code&gt;except&lt;/code&gt; 都没进入时才执行.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;函数&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;语法:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func(arg1, arg2=value, arg3=value):&#xA;    // do&#xA;    return ret1, ret2&#xA;&#xA;# 不定长参数&#xA;def func(arg1, *vartuple):&#xA;   &amp;quot;打印所有参数&amp;quot;&#xA;   print(arg1)&#xA;   for var in vartuple:&#xA;       print(var)&#xA;   return&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;定义函数时可以给参数指定默认值, 这样在调用时就可以不传入这些参数, 没有默认值的参数是必须要传入的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;定义默认参数要牢记一点：默认参数必须指向不变对象(数, 字符串, 元组)！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;参数前加了 &lt;code&gt;*&lt;/code&gt; 的变量会存放所有未命名的变量.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;__name__&lt;/code&gt; 是函数对象的一个属性, 可以拿到此函数的名称&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Lambda&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用关键字 &lt;code&gt;lambda&lt;/code&gt;, 就可以创建短小的匿名函式, 如:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 语法&#xA;lambda [arg1 [,arg2,.....argn]]:expression&#xA;&#xA;sum = lambda arg1, arg2: arg1 + arg2&#xA;print(sum(10, 10) # 20&#xA;print(sum(10, 20) # 30&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;特点:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;lambda&lt;/code&gt; 只是一个表达式, 函数体比 &lt;code&gt;def&lt;/code&gt; 简单的多, 近能封装有限的逻辑进去&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;lambda&lt;/code&gt; 函数拥有自己的命名空间, 并且不能访问自有参数之外或全局命名的参数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;lambda&lt;/code&gt; 函数虽然间短, 但不等同于 &lt;strong&gt;内联函数&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;装饰器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;当需要增强某个函数的功能时, 但有不希望修改函数, 此时可以使用装饰器. 如添加日志功能:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def log(func):&#xA;    def wrapper(*args, **kw):&#xA;        print(&#39;call %s():&#39; % func.__name__)&#xA;        return func(*args, **kw)&#xA;    return wrapper&#xA;&#xA;@log&#xA;def test():&#xA;    print(&amp;quot;Test&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过 &lt;code&gt;@&lt;/code&gt; 语法就给函数 &lt;code&gt;test&lt;/code&gt; 添加了日志功能&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;模块&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;模块就是一个 &lt;code&gt;python&lt;/code&gt; 文件, 使用 &lt;code&gt;import&lt;/code&gt; 导入模块, 调用模块中的方法时就必须以 &lt;code&gt;&amp;lt;module&amp;gt;.&amp;lt;func&amp;gt;&lt;/code&gt; 来调用.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;from &amp;lt;module&amp;gt; import &amp;lt;func1&amp;gt;,&amp;lt;func2&amp;gt;...&lt;/code&gt; 语句是从模块中导入指定的函数, &lt;code&gt;from &amp;lt;module&amp;gt; import *&lt;/code&gt; 则将模块中的所有方法都导入&lt;/p&gt;&#xA;&#xA;&lt;p&gt;导入一个模块时的路径搜索顺序如下:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;先从当前目录查找是否有此模块&lt;/li&gt;&#xA;&lt;li&gt;如果当前目录没有, 就从 &lt;code&gt;PYTHONPATH&lt;/code&gt; 定义的目录下查找&lt;/li&gt;&#xA;&lt;li&gt;如果都找不到, 就查看默认路径, &lt;code&gt;linux&lt;/code&gt; 下一般是 &lt;code&gt;/usr/lib/python&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;搜索路径定义在 &lt;code&gt;sys.path&lt;/code&gt; 中, 可以用 &lt;code&gt;append&lt;/code&gt; 函数来添加指定目录, 如项目中模块不再同一个目录就可以添加 &lt;code&gt;path&lt;/code&gt; 来导入&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;包&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 中的包就是一个分层次的目录, 定义了一个由模块及子包组成的环境.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;包简单来说就是一个目录, 目录中必须包含一个 &lt;code&gt;__init__.py&lt;/code&gt;, 该文件可以为空, 目的使用来标识这个目录是一个包, 一个简单的例子如下:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如存在目录 &lt;code&gt;package_test&lt;/code&gt; , 此目录下有 &lt;code&gt;__init__.py, foo1.py, foo2.py&lt;/code&gt; 等文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;foo1.py&lt;/code&gt; 文件:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3&#xA;# -*- coding: utf-8 -*-&#xA;&#xA;def foo1():&#xA;    print(&amp;quot;Foo1 test&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;foo2.py&lt;/code&gt; 文件:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3&#xA;# -*- coding: utf-8 -*-&#xA;&#xA;def foo2():&#xA;    print(&amp;quot;Foo2 test&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;调用:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3&#xA;# -*- coding: utf-8 -*-&#xA;&#xA;from package_test.foo1 import foo1&#xA;from package_test.foo2 import foo2&#xA;&#xA;if __name__ == &amp;quot;__main__&amp;quot;:&#xA;    foo1()&#xA;    foo2()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;类&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 是一门面向对象语言, 所以创建类和对象是很容易的, 先简单介绍下面向对象的一些基本特征:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类: 用来描述具有相同属性和方法的对象的集合, 定义了每个对象共有的属性和方法, 对象是类的实例&lt;/li&gt;&#xA;&lt;li&gt;数据成员: 类中的变量, 用于处理类及对象的相关的数据&lt;/li&gt;&#xA;&lt;li&gt;私有成员: 只能在类的内部方法中访问的成员&lt;/li&gt;&#xA;&lt;li&gt;受保护成员: 只能由本类或子类访问的成员&lt;/li&gt;&#xA;&lt;li&gt;公有成员: 全局的, 类内部, 外部和子类都能访问的成员&lt;/li&gt;&#xA;&lt;li&gt;方法: 类中定义的函数&lt;/li&gt;&#xA;&lt;li&gt;方法重写: 如果从父类继承的方法不满足需求, 可以对其重新实现, 这个过程就叫重写&lt;/li&gt;&#xA;&lt;li&gt;操作符重载: 自定义某些操作符的功能, 如 &lt;code&gt;+&lt;/code&gt; 操作符, 指明2个对象的数据如何相加&lt;/li&gt;&#xA;&lt;li&gt;继承: 从一个父类派生出一个子类&lt;/li&gt;&#xA;&lt;li&gt;多态: 如果多个对象都继承子一个父类, 通过传入一个父类变量来调用某个方法时, 如果此时传入的是子类的对象, 则会调用这个子类中实现的方法(方法已被重写)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;类的创建&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;python&lt;/code&gt; 中类创建的语法如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建一个类&#xA;class Human:&#xA;    # 类变量&#xA;    var1 = 0 # 公有成员&#xA;    _var2 = 0 # 受保护成员&#xA;    __var3 = 0 # 私有成员&#xA;&#xA;    # 构造函数, 也可以在里面定义类变量, 但这些变量在实例化之后才能使用&#xA;    def __init__(self, arg1, arg2...):&#xA;        self.arg1 = arg1&#xA;        self._arg2 = arg2&#xA;        self.__arg3 = arg3&#xA;&#xA;    # 类方法&#xA;    def foo(self):&#xA;        print(&amp;quot;Var1:&amp;quot;, var1)&#xA;        print(&amp;quot;Arg1:&amp;quot;, self.arg1)&#xA;&#xA;&amp;quot;&amp;quot;&amp;quot;&#xA;动态类型的语言在创建实例后, 可以给实例绑定任何的属性和方法, 但这些绑定只对当前实例有效&#xA;如果要对所以实例生效, 可以在创建实例前给动态的给类绑定&#xA;&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;# 动态的给类绑定属性和方法, 这些属性和方法所有实例都可用&#xA;Human.school = &#39;&#39;&#xA;# 实例化&#xA;h = Human(arg1, arg2...)&#xA;print(h.school)&#xA;# 方法调用&#xA;h.foo()&#xA;# 动态的给实例绑定属性和方法, 这些属性和方法只能该实例可用&#xA;h.parent = &#39;Big Joy&#39;&#xA;# 类的销毁&#xA;del h&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;类的实例化是通过调用构造函数完成的, &lt;code&gt;__init__&lt;/code&gt; 函数中定义了实例化时需要的参数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类中以一个 &lt;code&gt;_&lt;/code&gt; 开头命令的变量或方法叫做受保护成员, 以二个 &lt;code&gt;_&lt;/code&gt; 开头命名的叫做私有成员, 以 &lt;code&gt;__&lt;/code&gt; 开头并以 &lt;code&gt;__&lt;/code&gt; 结尾的为系统定义的, 一般是内置的成员.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;del&lt;/code&gt; 则可销毁一个类实例.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类内置了以下属性:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;__dict__:&lt;/strong&gt; 类的数据属性组成的字典&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__doc__:&lt;/strong&gt; 类的文档&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__name__:&lt;/strong&gt; 类名&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__module__:&lt;/strong&gt; 类定义所在的模块名&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__bases__:&lt;/strong&gt; 类继承的所有父类的元组&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;类的继承&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;语法如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class SubName(Parent1, Parent2...):&#xA;    pass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一个子类可以继承多个父类, 使用 &lt;code&gt;isintance(obj, type)&lt;/code&gt; 可以判断一个对象的类型, 使用 &lt;code&gt;issubclass(sub, parent)&lt;/code&gt; 可以判断是否为另一个类的子类.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;方法重写&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果父类的方法不能满足子类的需求, 子类就可重写此方法, 在使用子类对象调用此方法时会调用重写后的方法.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;运算符重载&lt;/strong&gt; 也是方法的重写, 只不过是对一些内置方法进行重写.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面列出一些基本的内置方法:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;__init__(self, [, args&amp;#x2026;]):&lt;/strong&gt; 构造函数, 用户实例化对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__del__(self):&lt;/strong&gt; 析构函数, 用于删除对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__repr__(self):&lt;/strong&gt; 转化为供解释器读取的形式&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__str__(self):&lt;/strong&gt; 用于将值转化为适于人阅读的形式&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__cmp__(self, obj):&lt;/strong&gt; 对象比较&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__add__(self, obj):&lt;/strong&gt; &amp;lsquo;+&amp;rsquo; 对象相加&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__sub__(self, obj):&lt;/strong&gt; &amp;lsquo;-&amp;rsquo; 对象相减&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__eq__(self, obj):&lt;/strong&gt; &amp;lsquo;==&amp;rsquo; 对象是否相等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__gt__(self, obj):&lt;/strong&gt; &amp;lsquo;&amp;gt;&amp;rsquo; 对象是否小于&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__lt__(self, obj):&lt;/strong&gt; &amp;lsquo;&amp;lt;&amp;rsquo; 对象是否小于&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;__iadd__(self, obj):&lt;/strong&gt; &amp;lsquo;+=&amp;rsquo; 对象相加&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;更多的内置方法请查阅手册&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;以上就介绍完了 &lt;code&gt;python&lt;/code&gt; 的基础知识, 按照上面的内容就能够写出 &lt;code&gt;python&lt;/code&gt; 程序了, 当然前提是你不是一个小白, 至少熟悉一门编程语言.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但 &lt;code&gt;python&lt;/code&gt; 还有很多高级知识则需要你自行使用学习了, 如文件操作, 进程和线程, 网络编程, 图形编程等等. 本文的目的只是让你明白 &lt;code&gt;python&lt;/code&gt; 程序应该怎么写, 怎么把你用其他语言写的程序转换成 &lt;code&gt;python&lt;/code&gt; 语言的, 更多高级的特性只能靠你自己学习尝试.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 包管理之module</title>
      <link>http://45.62.229.81:8080/Blog/Go-%E5%8C%85%E7%AE%A1%E7%90%86%E4%B9%8Bmodule/</link>
      <pubDate>2018-11-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Go Module 使用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Go Module&lt;/code&gt; 是官方用来管理 &lt;code&gt;package&lt;/code&gt; 依赖的工具, &lt;code&gt;1.11&lt;/code&gt; 新加的, 使用时需要设置变量: &lt;code&gt;GO111MODULE=on&lt;/code&gt; .&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;go mod help&lt;/code&gt; 可以查看其帮助文档:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go help mod&#xA;Go mod provides access to operations on modules.&#xA;&#xA;Note that support for modules is built into all the go commands,&#xA;not just &#39;go mod&#39;. For example, day-to-day adding, removing, upgrading,&#xA;and downgrading of dependencies should be done using &#39;go get&#39;.&#xA;See &#39;go help modules&#39; for an overview of module functionality.&#xA;&#xA;Usage:&#xA;&#xA;        go mod &amp;lt;command&amp;gt; [arguments]&#xA;&#xA;The commands are:&#xA;&#xA;        download    download modules to local cache&#xA;        edit        edit go.mod from tools or scripts&#xA;        graph       print module requirement graph&#xA;        init        initialize new module in current directory&#xA;        tidy        add missing and remove unused modules&#xA;        vendor      make vendored copy of dependencies&#xA;        verify      verify dependencies have expected content&#xA;        why         explain why packages or modules are needed&#xA;&#xA;Use &amp;quot;go help mod &amp;lt;command&amp;gt;&amp;quot; for more information about a command.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;下面来说明下如何使用.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;示例&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;go mod&lt;/code&gt; 要求项目必须在 &lt;code&gt;GOPATH&lt;/code&gt; 中, 所以在这个例子中设置为当前目录(&lt;code&gt;~/GoLang&lt;/code&gt;) &lt;code&gt;export GOPATH=$PWD&lt;/code&gt;, 然后在 &lt;code&gt;src&lt;/code&gt; 下创建项目 &lt;code&gt;test&lt;/code&gt; , 目录结构如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;GoLang&#xA;└── src&#xA;    └── test&#xA;        └── main.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;示例的代码请见: &lt;a href=&#34;https://github.com/jouyouyun/examples/tree/master/GoModule&#34;&gt;GoModule&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;初始化&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;进入 &lt;code&gt;test&lt;/code&gt; 所在目录, 执行 &lt;code&gt;go mod init&lt;/code&gt; 即可完成初始化, 会多出一个文件: &lt;code&gt;go.mod&lt;/code&gt; .&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;记录依赖&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;执行 &lt;code&gt;go get ./&lt;/code&gt; 即会开始查找依赖并下载记录到 &lt;code&gt;go.mod&lt;/code&gt; 文件中.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;go mod&lt;/code&gt; 会将依赖下载到 &lt;code&gt;$GOPATH/pkg&lt;/code&gt; 下, 用来当作缓存, 可以在多个项目之间共享.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;依赖变更及 vendor&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如在项目的开发过程中, 依赖有变更, 可使用 &lt;code&gt;go mod tidy&lt;/code&gt; 来应用这些变更到 &lt;code&gt;go.mod&lt;/code&gt; 文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在项目发布时会要将依赖复制到项目中, 此时使用 &lt;code&gt;go mod vendor&lt;/code&gt; 即可完成此操作.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;到此就介绍完了 &lt;code&gt;go mod&lt;/code&gt; 的用法, 其他的子命令用法请查看帮助文档.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后在说下需要注意的地方:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;项目必须要在 &lt;code&gt;GOPATH&lt;/code&gt; 中&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;需要设置 &lt;code&gt;GO111MODULE=on&lt;/code&gt; 变量&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux Signal Examples</title>
      <link>http://45.62.229.81:8080/Blog/Linux-Signal-Examples/</link>
      <pubDate>2018-11-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;信号是系统响应某些条件而产生的一个事件，接收到该信的进程做出相应的处理。通常信是由错误产生的，如段错误(&lt;code&gt;SIGSEGV&lt;/code&gt;)。 但信还可以作为进程间通信的一种方式，由一个进程发送给另一个进程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;信号定义在 &lt;code&gt;signal.h&lt;/code&gt; 文件中，以 &lt;code&gt;SIG&lt;/code&gt; 作为开头，可用 &lt;code&gt;kill -l&lt;/code&gt; 命令查看，详细信息参见 &lt;a href=&#34;http://man7.org/linux/man-pages/man7/signal.7.html&#34;&gt;man 7 signal&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;信号处理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;信号可以通过 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;sigaction&lt;/code&gt; 函数来注册处理， &lt;code&gt;signal&lt;/code&gt; 函数是 &lt;code&gt;struct sigaction&lt;/code&gt; 中 &lt;code&gt;sa_handler&lt;/code&gt; 的一种便捷实现。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;code&gt;signal&lt;/code&gt; 函数&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;原型：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void (*signal(int sig, void (*func)(int)))(int);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中 &lt;code&gt;sig&lt;/code&gt; 是需要捕获的 &lt;code&gt;signal number&lt;/code&gt;, 后一个是捕获到信号后的处理函数指针，所以处理函数的原型必须是 &lt;code&gt;void func(int)&lt;/code&gt; ，简单的代码示例如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;signal.h&amp;gt;&#xA;&#xA;static void&#xA;handler(int sig)&#xA;{&#xA;        printf(&amp;quot;Recieved signal: %d\n&amp;quot;, sig);&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        signal(SIGINT, handler);&#xA;&#xA;        printf(&amp;quot;Caught SIGINT, input &#39;quit&#39; to exit...\n&amp;quot;);&#xA;        // wait signal caught&#xA;        char buf[1024] = {0};&#xA;        while (1) {&#xA;                printf(&amp;quot;Please input: &amp;quot;);&#xA;                scanf(&amp;quot;%s&amp;quot;, buf);&#xA;                if (strcmp(buf, &amp;quot;quit&amp;quot;) == 0) {&#xA;                        break;&#xA;                }&#xA;        }&#xA;        printf(&amp;quot;Exit...\n&amp;quot;);&#xA;        return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;另外 &lt;code&gt;api&lt;/code&gt; 中也提供了下面 2 个特殊的 &lt;code&gt;handler&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;SIG_IGN&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;忽略此信号&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;SIG_DFL&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;恢复此信号的默认行为&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;&lt;code&gt;sigaction&lt;/code&gt; 函数&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;原型：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sigaction(int sig, const struct sigaction *restrict act,&#xA;           struct sigaction *restrict oact);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中 &lt;code&gt;sig&lt;/code&gt; 为 &lt;code&gt;signal number&lt;/code&gt;, &lt;code&gt;act&lt;/code&gt; 指定信号的处理行为， &lt;code&gt;oact&lt;/code&gt; 如果不为 &lt;code&gt;NULL&lt;/code&gt; 则返回信号之前的处理行为。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;struct sigaction&lt;/code&gt; 的主要成员如下：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;类型&lt;/th&gt;&#xA;&lt;th&gt;名称&lt;/th&gt;&#xA;&lt;th&gt;描述&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;void(*) (int)&lt;/td&gt;&#xA;&lt;td&gt;sa_handler&lt;/td&gt;&#xA;&lt;td&gt;处理函数指针，同 signal 函数中的 &lt;code&gt;func&lt;/code&gt; 参数&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;sigset_t&lt;/td&gt;&#xA;&lt;td&gt;sa_mask&lt;/td&gt;&#xA;&lt;td&gt;信号屏蔽字，是指当前被阻塞的一组信号，不能被当前进程收到&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;int&lt;/td&gt;&#xA;&lt;td&gt;sa_flags&lt;/td&gt;&#xA;&lt;td&gt;处理行为修改器，指明哪种处理函数生效，详见下文&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;void(*) (int, siginfo_t *, void *)&lt;/td&gt;&#xA;&lt;td&gt;sa_sigaction&lt;/td&gt;&#xA;&lt;td&gt;处理函数指针，仅 sa_flags == SA_SIGINFO 时有效&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;其中 &lt;code&gt;sa_flags&lt;/code&gt; 主要可以设置为以下值：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;SA_NOCLDSTOP&lt;/p&gt;&#xA;&#xA;&lt;p&gt;子进程停止时不产生 &lt;code&gt;SIGCHLD&lt;/code&gt; 信号&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SA_RESETHAND&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将信号的处理函数在处理函数的入口重置为 &lt;code&gt;SIG_DFL&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SA_RESTART&lt;/p&gt;&#xA;&#xA;&lt;p&gt;重启可中断的函数而不是给出 &lt;code&gt;EINTR&lt;/code&gt; 错误&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SA_SIGINFO&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;sa_sigaction&lt;/code&gt; 做为信号的处理函数&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SA_NODEFER&lt;/p&gt;&#xA;&#xA;&lt;p&gt;捕获到信号时不将它添加到信号屏蔽字中&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;简单的代码示例如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;#include &amp;lt;signal.h&amp;gt;&#xA;&#xA;#define SIG SIGINT&#xA;&#xA;static void&#xA;sig_handler(int sig, siginfo_t *si, void *data)&#xA;{&#xA;        printf(&amp;quot;Caught signal: %d\n&amp;quot;, sig);&#xA;        printf(&amp;quot;Sender pid: %d\n&amp;quot;, si-&amp;gt;si_pid);&#xA;        printf(&amp;quot;Sender uid: %d\n&amp;quot;, si-&amp;gt;si_uid);&#xA;}&#xA;&#xA;static int&#xA;sig_caught(int sig)&#xA;{&#xA;        printf(&amp;quot;Start caught signal: %d\n&amp;quot;, sig);&#xA;        struct sigaction sa;&#xA;        sa.sa_flags = SA_SIGINFO;&#xA;        sa.sa_sigaction = sig_handler;&#xA;        sigemptyset(&amp;amp;sa.sa_mask);&#xA;        int ret = sigaction(sig, &amp;amp;sa, NULL);&#xA;        if (ret == -1) {&#xA;                printf(&amp;quot;Failed to caught signal: %d\n&amp;quot;, sig);&#xA;                return -1;&#xA;        }&#xA;&#xA;        return 0;&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        if (sig_caught(SIG) == -1) {&#xA;                return -1;&#xA;        }&#xA;&#xA;        printf(&amp;quot;Caught signal(%d), input &#39;quit&#39; to exit...\n&amp;quot;, SIG);&#xA;        char buf[1024] = {0};&#xA;        while(1) {&#xA;                printf(&amp;quot;Please input: &amp;quot;);&#xA;                scanf(&amp;quot;%s&amp;quot;, buf);&#xA;                if (strcmp(buf, &amp;quot;quit&amp;quot;) == 0) {&#xA;                        break;&#xA;                }&#xA;        }&#xA;        printf(&amp;quot;Exit...\n&amp;quot;);&#xA;        return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;信号屏蔽字&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;考虑一下这种情况：在 &lt;code&gt;signal()/sigaction()&lt;/code&gt; 返回之前进程就已经收到了需要处理的信号，此时进程会以默认行为来处理，这显然不符合我们的期望。 这时就需要用到信号屏蔽字了，在进程启动时就将需要处理的信号加入的屏蔽字中，等 &lt;code&gt;signal()/sigaction()&lt;/code&gt; 返回后再解除屏蔽，解除屏蔽后至少会将收到的待处理信号发送一个给进程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;屏蔽字用到一下函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sigemptyset(sigset_t *set);&#xA;int sigaddset(sigset_t *set, int signo);&#xA;int sigprocmask(int how, const sigset_t *restrict set,&#xA;           sigset_t *restrict oset);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sigprocmask&lt;/code&gt; 中 &lt;code&gt;set&lt;/code&gt; 为需要设置的屏蔽字集， &lt;code&gt;oset&lt;/code&gt; 为之前的屏蔽字集， &lt;code&gt;how&lt;/code&gt; 控制着 &lt;code&gt;set&lt;/code&gt; 如何生效，可设置为以下值：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;SIG_BLOCK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该进程的屏蔽字集将为当期屏蔽字集与 &lt;code&gt;set&lt;/code&gt; 的并集， &lt;code&gt;set&lt;/code&gt; 中包含了需要屏蔽的信号集&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SIG_UNBLOCK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该进程的屏蔽字集将为当期屏蔽字集与 &lt;code&gt;set&lt;/code&gt; 的补集的交集， &lt;code&gt;set&lt;/code&gt; 中包含了需要解除屏蔽的信号集&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;SIG_SETMASK&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该进程的屏蔽字集将设置为 &lt;code&gt;set&lt;/code&gt; 的值&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;简单的设置流程如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int&#xA;sig_block(int sig, int how)&#xA;{&#xA;        sigset_t mask;&#xA;        sigemptyset(&amp;amp;mask)&#xA;        sigaddset(&amp;amp;mask, sig);&#xA;        sigprocmask(how, &amp;amp;mask, NULL);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;信号发送&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;信号可以通过 &lt;code&gt;kill&lt;/code&gt; 函数发送给指定进程，也可以通过 &lt;code&gt;raise&lt;/code&gt; 或者 &lt;code&gt;alarm&lt;/code&gt; 函数发送给当前执行的线程或进程，下面来分别说说这几个函数。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;kill&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;原型：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int kill(pid_t pid, int sig);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;kill&lt;/code&gt; 函数向指定进程发送指定的信号，如果信号为 0 将执行错误检查，信号并不会发送，可以用来检查 &lt;code&gt;pid&lt;/code&gt; 的有效性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;pid&lt;/code&gt; 大于 0 时信号将发送给此进程， &lt;code&gt;pid&lt;/code&gt; 小于等于 0 时，如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;等于 0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;信号将发送给发送者所在组里的所有进程&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;等于 -1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;信号将发送给所有进程&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;小于 -1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;信号将发送给进程组为 &lt;code&gt;pid&lt;/code&gt; 绝对值的所有组内进程&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;alarm&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;原型：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned alarm(unsigned seconds);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;alarm&lt;/code&gt; 函数将在指定的 &lt;code&gt;seconds&lt;/code&gt; 之后发送一个 &lt;code&gt;SIGALRM&lt;/code&gt; 信号，如果 &lt;code&gt;seconds&lt;/code&gt; 为 0, 则取消之前的定时器请求。如果不为 0 则取消之前的请求，重新设置为 &lt;code&gt;seconds&lt;/code&gt; 。 如果在等待结束之前有其他的事件产生，那定时器请求也将被取消。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;简单的代码示例如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;unistd.h&amp;gt;&#xA;#include &amp;lt;signal.h&amp;gt;&#xA;&#xA;static void&#xA;handler(int sig)&#xA;{&#xA;        printf(&amp;quot;alarm arrived: %d\n&amp;quot;, sig);&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        signal(SIGALRM, handler);&#xA;&#xA;        alarm(2);&#xA;&#xA;        sleep(2);&#xA;        printf(&amp;quot;alarm 5s over\n&amp;quot;);&#xA;&#xA;        alarm(10);&#xA;        sleep(1);&#xA;&#xA;        unsigned int remaining = alarm(3);&#xA;        printf(&amp;quot;alarm 10s remain: %u, reset to 3\n&amp;quot;, remaining);&#xA;        sleep(3);&#xA;        printf(&amp;quot;alarm 3s over\n&amp;quot;);&#xA;&#xA;        alarm(20);&#xA;        sleep(3);&#xA;&#xA;        remaining = alarm(0);&#xA;        printf(&amp;quot;cancel alarm 20s, remian: %u, exit...\n&amp;quot;, remaining);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;raise&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;原型：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int raise(int sig);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;raise&lt;/code&gt; 函数将给当前执行的线程或进程发送信号，如果信号处理函数已经被调用， &lt;code&gt;raise&lt;/code&gt; 函数将等待信号处理函数调用结束才返回。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;结语&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;信号处理函数是会被重复调用的，所以必要保存其是可重入的，注意处理逻辑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外本文中的代码都在 &lt;a href=&#34;https://github.com/jouyouyun/examples/tree/master/signal&#34;&gt;signal&lt;/a&gt; 中，这个 &lt;code&gt;repo&lt;/code&gt; 也有其它的示例，有兴趣的可以看看。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;附录&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;信号表&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* ISO C99 signals.  */&#xA;#define&#x9;SIGINT&#x9;&#x9;2&#x9;/* Interactive attention signal.  */&#xA;#define&#x9;SIGILL&#x9;&#x9;4&#x9;/* Illegal instruction.  */&#xA;#define&#x9;SIGABRT&#x9;&#x9;6&#x9;/* Abnormal termination.  */&#xA;#define&#x9;SIGFPE&#x9;&#x9;8&#x9;/* Erroneous arithmetic operation.  */&#xA;#define&#x9;SIGSEGV&#x9;&#x9;11&#x9;/* Invalid access to storage.  */&#xA;#define&#x9;SIGTERM&#x9;&#x9;15&#x9;/* Termination request.  */&#xA;&#xA;/* Historical signals specified by POSIX. */&#xA;#define&#x9;SIGHUP&#x9;&#x9;1&#x9;/* Hangup.  */&#xA;#define&#x9;SIGQUIT&#x9;&#x9;3&#x9;/* Quit.  */&#xA;#define&#x9;SIGTRAP&#x9;&#x9;5&#x9;/* Trace/breakpoint trap.  */&#xA;#define&#x9;SIGKILL&#x9;&#x9;9&#x9;/* Killed.  */&#xA;#define SIGBUS&#x9;&#x9;10&#x9;/* Bus error.  */&#xA;#define&#x9;SIGSYS&#x9;&#x9;12&#x9;/* Bad system call.  */&#xA;#define&#x9;SIGPIPE&#x9;&#x9;13&#x9;/* Broken pipe.  */&#xA;#define&#x9;SIGALRM&#x9;&#x9;14&#x9;/* Alarm clock.  */&#xA;&#xA;/* New(er) POSIX signals (1003.1-2008, 1003.1-2013).  */&#xA;#define&#x9;SIGURG&#x9;&#x9;16&#x9;/* Urgent data is available at a socket.  */&#xA;#define&#x9;SIGSTOP&#x9;&#x9;17&#x9;/* Stop, unblockable.  */&#xA;#define&#x9;SIGTSTP&#x9;&#x9;18&#x9;/* Keyboard stop.  */&#xA;#define&#x9;SIGCONT&#x9;&#x9;19&#x9;/* Continue.  */&#xA;#define&#x9;SIGCHLD&#x9;&#x9;20&#x9;/* Child terminated or stopped.  */&#xA;#define&#x9;SIGTTIN&#x9;&#x9;21&#x9;/* Background read from control terminal.  */&#xA;#define&#x9;SIGTTOU&#x9;&#x9;22&#x9;/* Background write to control terminal.  */&#xA;#define&#x9;SIGPOLL&#x9;&#x9;23&#x9;/* Pollable event occurred (System V).  */&#xA;#define&#x9;SIGXCPU&#x9;&#x9;24&#x9;/* CPU time limit exceeded.  */&#xA;#define&#x9;SIGXFSZ&#x9;&#x9;25&#x9;/* File size limit exceeded.  */&#xA;#define&#x9;SIGVTALRM&#x9;26&#x9;/* Virtual timer expired.  */&#xA;#define&#x9;SIGPROF&#x9;&#x9;27&#x9;/* Profiling timer expired.  */&#xA;#define&#x9;SIGUSR1&#x9;&#x9;30&#x9;/* User-defined signal 1.  */&#xA;#define&#x9;SIGUSR2&#x9;&#x9;31&#x9;/* User-defined signal 2.  */&#xA;&#xA;/* Nonstandard signals found in all modern POSIX systems&#xA;   (including both BSD and Linux).  */&#xA;#define&#x9;SIGWINCH&#x9;28&#x9;/* Window size change (4.3 BSD, Sun).  */&#xA;&#xA;/* Archaic names for compatibility.  */&#xA;#define&#x9;SIGIO&#x9;&#x9;SIGPOLL&#x9;/* I/O now possible (4.2 BSD).  */&#xA;#define&#x9;SIGIOT&#x9;&#x9;SIGABRT&#x9;/* IOT instruction, abort() on a PDP-11.  */&#xA;#define&#x9;SIGCLD&#x9;&#x9;SIGCHLD&#x9;/* Old System V name */&#xA;&#xA;/* Not all systems support real-time signals.  bits/signum.h indicates&#xA;   that they are supported by overriding __SIGRTMAX to a value greater&#xA;   than __SIGRTMIN.  These constants give the kernel-level hard limits,&#xA;   but some real-time signals may be used internally by glibc.  Do not&#xA;   use these constants in application code; use SIGRTMIN and SIGRTMAX&#xA;   (defined in signal.h) instead.  */&#xA;#define __SIGRTMIN&#x9;32&#xA;#define __SIGRTMAX&#x9;__SIGRTMIN&#xA;&#xA;/* Biggest signal number + 1 (including real-time signals).  */&#xA;#define _NSIG&#x9;&#x9;(__SIGRTMAX + 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>怎么处理 &#39;Origin&#39;值从&#39;Google, Inc.&#39;修改到了&#39;Google LLC&#39; 的 APT 错误</title>
      <link>http://45.62.229.81:8080/Blog/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86-%27Origin%27%E5%80%BC%E4%BB%8E%27Google%2C-Inc.%27%E4%BF%AE%E6%94%B9%E5%88%B0%E4%BA%86%27Google-LLC%27-%E7%9A%84-APT-%E9%94%99%E8%AF%AF/</link>
      <pubDate>2018-11-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在执行 &lt;code&gt;sudo apt-get update&lt;/code&gt; 出现了下面的错误提示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;E: 仓库&#39;http://dl.google.com/linux/chrome/deb stable Release&#39;将其&#39;Origin&#39;值从&#39;Google, Inc.&#39;修改到了&#39;Google LLC&#39;&#xA;N: 为了让这个仓库能够应用，这必须在更新之前显式接受。更多细节请参阅 apt-secure(8) 手册。&#xA;&#xA;# 英语环境下的输出&#xA;E: Repository ‘http://dl.google.com/linux/chrome-remote-desktop/deb stable Release’ changed its ‘Origin’ value from ‘Google, Inc.’ to ‘Google LLC’&#xA;N: This must be accepted explicitly before updates for this repository can be applied. See apt-secure(8) manpage for details.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个错误导致无法升级系统，错误说明了原因：是由于 &lt;code&gt;Google Chrome&lt;/code&gt; 的 &lt;code&gt;Origin&lt;/code&gt; 改变引起的，也给出了解决思路：手动接受这个改变。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以修复这个错误就很容易了，只需执行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行后会看到下面的提示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;E: 仓库&#39;http://dl.google.com/linux/chrome/deb stable Release&#39;将其&#39;Origin&#39;值从&#39;Google, Inc.&#39;修改到了&#39;Google LLC&#39;&#xA;N: 为了让这个仓库能够应用，这必须在更新之前显式接受。更多细节请参阅 apt-secure(8) 手册。&#xA;您是否愿意接受这些更改，并且继续从此仓库更新？ [y/N] y&#xA;&#xA;# 英语环境下的输出&#xA;E: Repository ‘http://dl.google.com/linux/chrome-remote-desktop/deb stable Release’ changed its ‘Origin’ value from ‘Google, Inc.’ to ‘Google LLC’&#xA;N: This must be accepted explicitly before updates for this repository can be applied. See apt-secure(8) manpage for details.&#xA;Do you want to accept these changes and continue updating from this repository? [y/N] y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;此时输入 &lt;code&gt;y&lt;/code&gt; 接受就可解决问题。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>linux 下 deepin 和 gnome 桌面的外观设置</title>
      <link>http://45.62.229.81:8080/Blog/linux-%E4%B8%8B-deepin-%E5%92%8C-gnome-%E6%A1%8C%E9%9D%A2%E7%9A%84%E5%A4%96%E8%A7%82%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>2018-10-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;桌面的外观设置一般包括窗口主题、图标主题、光标主题和字体设置，其中窗口主题就是常见的 &lt;code&gt;gtk&lt;/code&gt; 主题，字体设置又包括标准字体、等款字体和字体大小。对于进些年的高分屏，又添加了字体缩放和窗口缩放这2个选项。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;界面上设置方法就不介绍了，都可以在各自桌面的控制中心中找到，这里主要介绍命令行下的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt; 和 &lt;code&gt;gnome&lt;/code&gt; 桌面环境的外观配置数据是使用 &lt;code&gt;gsettings&lt;/code&gt; 来存储，所以可以通过 &lt;code&gt;gsettings&lt;/code&gt; 来设置和读取。&lt;code&gt;gsettings&lt;/code&gt; 相比设置界面就是 可以设置到更多的选项，设置的值更加精确。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面先简单介绍下 &lt;code&gt;gsettings&lt;/code&gt; 的用法。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;GSettings&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;获取 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings get &amp;lt;schema_id&amp;gt; &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings set &amp;lt;schema_id&amp;gt; &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;其中 &lt;code&gt;schema&lt;/code&gt; 是在 &lt;code&gt;/usr/share/glib-2.0/schemas&lt;/code&gt; 这个目录下，&lt;code&gt;schema_id&lt;/code&gt; 是文件内容中 &lt;code&gt;id&lt;/code&gt; 的值，&lt;code&gt;key&lt;/code&gt; 就是文件中描述的，每个 &lt;code&gt;key&lt;/code&gt; 都有一个默认值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如 &lt;code&gt;deepin&lt;/code&gt; 的主题配置文件是 &lt;code&gt;com.deepin.dde.appearance.gchema.xml&lt;/code&gt;，通过其文件开头的内容 &lt;code&gt;&amp;lt;schema path=&amp;quot;/com/deepin/dde/appearance/&amp;quot; id=&amp;quot;com.deepin.dde.appearance&amp;quot; gettext-domain=&amp;quot;DDE&amp;quot;&amp;gt;&#xA;&lt;/code&gt; 可知，其 &lt;code&gt;schema_id&lt;/code&gt; 就是 &lt;code&gt;com.deepin.dde.appearance&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;外观设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt; 的外观配置的 &lt;code&gt;id&lt;/code&gt; 是 &lt;code&gt;org.gnome.desktop.interface&lt;/code&gt;，&lt;code&gt;deepin&lt;/code&gt; 的则是 &lt;code&gt;com.deepin.dde.appearance&lt;/code&gt; 和 &lt;code&gt;com.deepin.xsettings&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过命令 &lt;code&gt;gsettings list-keys &amp;lt;schema_id&amp;gt;&lt;/code&gt; 可以查询到所有支持的 &lt;code&gt;key&lt;/code&gt;，如查询 &lt;code&gt;gnome&lt;/code&gt; 支持的 &lt;code&gt;key&lt;/code&gt;：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gsettings list-keys org.gnome.desktop.interface&#xA;gtk-theme&#xA;cursor-blink-timeout&#xA;gtk-color-palette&#xA;gtk-timeout-repeat&#xA;toolkit-accessibility&#xA;cursor-theme&#xA;toolbar-style&#xA;toolbar-icons-size&#xA;text-scaling-factor&#xA;icon-theme&#xA;gtk-timeout-initial&#xA;scaling-factor&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;每个 &lt;code&gt;key&lt;/code&gt; 的含义请阅读对应的 &lt;code&gt;schema&lt;/code&gt; 文件来查询。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;窗口主题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;窗口主题对应的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;gtk-theme&lt;/code&gt;，值是字符串类型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所有系统附带的 &lt;code&gt;gtk&lt;/code&gt; 主题都在 &lt;code&gt;/usr/share/themes&lt;/code&gt; 目录下。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;读取&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings get org.gnome.desktop.interface gtk-theme&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings get com.deepin.dde.appearance gtk-theme&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;设置&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;如设置 &lt;code&gt;Adapta&lt;/code&gt; 作为窗口主题&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings set org.gnome.desktop.interface gtk-theme Adapta&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings set com.deepin.dde.appearance gtk-them Adapta&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h4&gt;恢复默认值&lt;/h4&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings reset org.gnome.desktop.interface gtk-theme&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings reset com.deepin.dde.appearance gtk-theme&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;图标和光标主题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;图标主题的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;icon-theme&lt;/code&gt;，光标主题的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;cursor-theme&lt;/code&gt;，值都是字符串类型，系统附带的图标和光标主题都在 &lt;code&gt;/usr/share/icons/&lt;/code&gt; 目录下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;主题的设置和获取方法与上面的窗口主题一样，这里就不再赘述了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;字体设置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt; 标准字体设置的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;font-name&lt;/code&gt;，等宽字体的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;monospace-font-name&lt;/code&gt;，值也都是字符串类型，字体的大小附加在字体名称后面一起设置，如设置标准字体：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gsettings set org.gnome.desktop.interface font-name &#39;Cantarell 11&#39;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt; 下标准字体的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;font-standard&lt;/code&gt;，等宽字体的是 &lt;code&gt;font-monospace&lt;/code&gt;，值也是字符串类型。但它的字体大小是单独在 &lt;code&gt;font-size&lt;/code&gt; 中设置的，值是浮点数类型。&#xA;使用 &lt;code&gt;gsettings&lt;/code&gt; 操作的方法就不再赘述了，与窗口主题一致。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;code&gt;HIDPI&lt;/code&gt; 缩放&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gnome&lt;/code&gt; 下字体缩放的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;text-scaling-factor&lt;/code&gt;，它的值是浮点数类型；窗口缩放的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;scaling-factor&lt;/code&gt;，但它的值是无符号整型，即非负的整数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt; 下缩放的 &lt;strong&gt;&lt;code&gt;schema_id&lt;/code&gt;&lt;/strong&gt; 变为了 &lt;strong&gt;&lt;code&gt;com.deepin.xsettings&lt;/code&gt;&lt;/strong&gt;，字体缩放的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;scale-factor&lt;/code&gt;，它的值也是浮点数类型；窗口缩放的 &lt;code&gt;key&lt;/code&gt; 是 &lt;code&gt;window-scale&lt;/code&gt;，它的值也是无符号整型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;只有在设置 &lt;code&gt;deepin&lt;/code&gt; 缩放时 &lt;code&gt;schema_id&lt;/code&gt; 才是 &lt;code&gt;com.deepin.xsettings&lt;/code&gt;，其他的设置时都是 &lt;code&gt;com.deepin.dde.appearance&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;以上介绍的设置方法在使用 &lt;code&gt;deepin&lt;/code&gt; 或 &lt;code&gt;gnome&lt;/code&gt; 作为桌面的 &lt;code&gt;linux&lt;/code&gt; 发行版都可以适用，如 &lt;code&gt;ubuntu&lt;/code&gt;，&lt;code&gt;fedora&lt;/code&gt; 和 &lt;code&gt;deepin&lt;/code&gt; 等，这些设置的改变桌面环境是会实时响应。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;希望这些能够帮助到你，如写一个自动备份和恢复的脚本等&amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你是想知道这些设置是如何生效的，请持续关注哦，本人计划在下篇文章中介绍 &lt;code&gt;deepin&lt;/code&gt; 下的实现原理，谢谢支持。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux 休眠自动唤醒</title>
      <link>http://45.62.229.81:8080/Blog/Linux-%E4%BC%91%E7%9C%A0%E8%87%AA%E5%8A%A8%E5%94%A4%E9%86%92/</link>
      <pubDate>2018-10-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近做无线网络在系统多次休眠唤醒后是否正常的测试，但每次休眠后都需要手动点击键盘来唤醒系统，显而易见的这种方法需要人来值守，很不放便。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时便想是否有做自动唤醒的程序，毕竟这种需求也挺正常的，应该有人已经做过了。因此就开始查找自动唤醒的方法，果然就发现了 &lt;code&gt;rtcwake&lt;/code&gt; 这个程序，这个程序是让系统进入休眠模式并在指定的时间后唤醒。立刻便觉得这个程序很神奇，然后就去看它的源码来找出它的实现方式，这边发现了本文的主题 &lt;code&gt;RTC&lt;/code&gt; 子系统。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;RTC&lt;/code&gt; 子系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;RTC&lt;/code&gt; 子系统在目录 &lt;code&gt;/sys/class/rtc/&lt;/code&gt; 下，会根据设备创建对应的目录，需要在内核中开启支持，配置如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CONFIG_HPET_EMULATE_RTC=y&#xA;CONFIG_PM_TRACE_RTC=y&#xA;CONFIG_RTC_LIB=y&#xA;CONFIG_RTC_CLASS=y&#xA;CONFIG_RTC_HCTOSYS=y&#xA;CONFIG_RTC_HCTOSYS_DEVICE=&amp;quot;rtc0&amp;quot;&#xA;# CONFIG_RTC_DEBUG is not set&#xA;# RTC interfaces&#xA;CONFIG_RTC_INTF_SYSFS=y&#xA;CONFIG_RTC_INTF_PROC=y&#xA;... (略)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;debian/ubuntu&lt;/code&gt; 的系统可以在 &lt;code&gt;/boot/config-$(uname -r)&lt;/code&gt; 查看内核的编译选项，&lt;code&gt;archlinux&lt;/code&gt; 可以在 &lt;code&gt;/proc/config.gz&lt;/code&gt; 查看。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;RTC&lt;/code&gt; 目录下的文件含义可以在 &lt;a href=&#34;https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-rtc&#34;&gt;sysfs-class-rtc&lt;/a&gt; 中查看。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;code&gt;wakealarm&lt;/code&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;RTC&lt;/code&gt; 目录中的 &lt;code&gt;wakealarm&lt;/code&gt; 文件内容便是下次触发唤醒时间的时间，默认这个文件是没有值的。文件的内容需要设置是时间的秒数，可以向下面这样设置：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# echo $(date +%s --date &#39;now + 1 minutes&#39;) &amp;gt; /sys/class/rtc/rtc0/wakealarm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这就表示在 &lt;code&gt;1 minute&lt;/code&gt; 后触发唤醒事件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以做休眠唤醒测试的流程如下：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;设置下次唤醒的时间到 &lt;code&gt;wakealarm&lt;/code&gt; 中&lt;/li&gt;&#xA;&lt;li&gt;休眠系统&lt;/li&gt;&#xA;&lt;li&gt;被 &lt;code&gt;wakealarm&lt;/code&gt; 唤醒后，开始做一些期望的事情(如检查系统是否正常)，然后继续执行步骤 &lt;code&gt;1&lt;/code&gt;，就这样一直循环，直至满足条件后终止&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;FAQ&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置无效？&#xA;首先检查内涵是否开启了 &lt;code&gt;rtc&lt;/code&gt; 支持，如果支持就检查时间标准是否是 &lt;code&gt;UTC&lt;/code&gt;，&lt;code&gt;localtime&lt;/code&gt; 时间标准时设置 &lt;code&gt;wakealarm&lt;/code&gt; 是不生效的，内容一直是空的。通过 &lt;code&gt;timedatectl&lt;/code&gt; 命令可以查询和设置时间标准。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Linux 时间标准</title>
      <link>http://45.62.229.81:8080/Blog/Linux-%E6%97%B6%E9%97%B4%E6%A0%87%E5%87%86/</link>
      <pubDate>2018-08-27 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;系统如何设置时间&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开机时根据硬件时钟来设置系统时钟.&lt;/li&gt;&#xA;&lt;li&gt;如果开启了 &lt;code&gt;NTP&lt;/code&gt; 服务, 会根据网络时间来校正系统时钟，确保时间准确.&lt;/li&gt;&#xA;&lt;li&gt;关机时会根据系统时钟来设置硬件时钟(&lt;code&gt;localtime&lt;/code&gt; 标准除外).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;时钟&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件时钟: 即实时时钟 &lt;code&gt;RTC&lt;/code&gt; 或 &lt;code&gt;CMOS&lt;/code&gt; 时钟, 仅能保存年、月、日、时、分、秒这些时间数值，无法保存时间标准和是否使用夏令时调节.&lt;/li&gt;&#xA;&lt;li&gt;系统时钟: 即软件时间, 与硬件时间分别维护，保存了时间、时区和夏令时设置.初始系统时钟是从硬件时间计算得来，计算时会考虑 &lt;code&gt;/etc/adjtime&lt;/code&gt; 的设置.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;/etc/adjtime&lt;/code&gt;: 这个文件中记录了时区标准和时间偏移, 根据硬件时钟设置系统时间和设置硬件时钟都会根据时间偏移来计算的.所有的时钟都是有误差的，但是一般有固定的偏移, 这种于基值的差称为“time skew”或“时间偏移”.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;时间标准&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;UTC&lt;/code&gt; 是与时区无关的全球时间标准, 会根据夏令时自动调整时间, &lt;strong&gt;推荐使用&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;localtime&lt;/code&gt; 则依赖于当前时区, 不会根据夏令时自动调整.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;通常在 &lt;code&gt;window+linux&lt;/code&gt; 双系统中遇到的时间问题就是使用的时间标准不一致导致的，只要将两个系统的时间标准调成一致的，就能解决此问题，推荐将 &lt;code&gt;window&lt;/code&gt; 的时间标准改为 &lt;code&gt;UTC&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;示例&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;假设当前 &lt;code&gt;RTC&lt;/code&gt; 时间为 &lt;code&gt;12:00&lt;/code&gt;, 时区为 &lt;code&gt;Asia/Shanghai&lt;/code&gt;, 时区的 &lt;code&gt;offset&lt;/code&gt; 为8, 两种不同的时间标准的处理如下:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;UTC&lt;/code&gt; 时间标准: 系统开机时会根据 &lt;code&gt;RTC&lt;/code&gt; 时间和时区的 &lt;code&gt;offset&lt;/code&gt; 将系统时间调整为 &lt;code&gt;20:00&lt;/code&gt;, &lt;code&gt;UTC&lt;/code&gt; 时区的时间为 &lt;code&gt;12:00&lt;/code&gt;, 关机时使用 &lt;code&gt;UTC&lt;/code&gt; 的时间来设置 &lt;code&gt;RTC&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;localtime&lt;/code&gt; 时间标准: 开始时根据 &lt;code&gt;RTC&lt;/code&gt; 和时区 &lt;code&gt;offset&lt;/code&gt;, 将系统时间调整为 &lt;code&gt;12:00&lt;/code&gt;, &lt;code&gt;UTC&lt;/code&gt; 时区的时间为 &lt;code&gt;04:00&lt;/code&gt;, 关机时不再设置 &lt;code&gt;RTC&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;如果开启了 &lt;code&gt;NTP&lt;/code&gt; 服务, 系统会在运行时通过网络时间校准本机的 &lt;code&gt;UTC&lt;/code&gt; 时间, 本机的 &lt;code&gt;UTC&lt;/code&gt; 时间改变后, 系统时钟的时间也会跟着改变. 所以建议开启 &lt;code&gt;NTP&lt;/code&gt; 服务, 这能保证时间的准确性，&#xA;但如果采用的是 &lt;code&gt;localtime&lt;/code&gt; 时间标准，在 &lt;code&gt;NTP&lt;/code&gt; 同步后不会修改 &lt;code&gt;RTC&lt;/code&gt; 时间。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;systemd 时间服务&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;timedatectl&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;用来查询和设置系统时间的命令, 使用方法如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;timedatectl [OPTIONS...] COMMAND ...&#xA;&#xA;Query or change system time and date settings.&#xA;&#xA;-h --help                Show this help message&#xA;--version             Show package version&#xA;--no-pager            Do not pipe output into a pager&#xA;--no-ask-password     Do not prompt for password&#xA;-H --host=[USER@]HOST    Operate on remote host&#xA;-M --machine=CONTAINER   Operate on local container&#xA;--adjust-system-clock Adjust system clock when changing local RTC mode&#xA;&#xA;Commands:&#xA;status                   Show current time settings&#xA;set-time TIME            Set system time&#xA;set-timezone ZONE        Set system time zone&#xA;list-timezones           Show known time zones&#xA;set-local-rtc BOOL       Control whether RTC is in local time&#xA;set-ntp BOOL             Enable or disable network time synchronization&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置时区时会创建一个 &lt;code&gt;/etc/localtime&lt;/code&gt; 软链接，指向 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; 中的时区文件.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;systemd-timesyncd&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;提供了时间同步的功能, 基于 &lt;code&gt;SNTP&lt;/code&gt; 实现, &lt;code&gt;SNTP&lt;/code&gt; 是 &lt;code&gt;NTP&lt;/code&gt; 协议的一种简单实现, 不需要长时间的存储状态, 适用与非服务器的桌面系统和嵌入式系统.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deepin&lt;/code&gt; 的时间同步功能就是用它实现的.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;systemd-timedated&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;timedatectl&lt;/code&gt; 的功能的 &lt;code&gt;dbus&lt;/code&gt; 接口, 提供的方法和属性如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gdbus introspect --system --dest org.freedesktop.timedate1 --object-path /org/freedesktop/timedate1&#xA;node /org/freedesktop/timedate1 {&#xA;interface org.freedesktop.timedate1 {&#xA;methods:&#xA;SetTime(in  x usec_utc,&#xA;in  b relative,&#xA;in  b user_interaction);&#xA;SetTimezone(in  s timezone,&#xA;in  b user_interaction);&#xA;SetLocalRTC(in  b local_rtc,&#xA;in  b fix_system,&#xA;in  b user_interaction);&#xA;SetNTP(in  b use_ntp,&#xA;in  b user_interaction);&#xA;signals:&#xA;properties:&#xA;readonly s Timezone = &#39;Europe/Berlin&#39;;&#xA;readonly b LocalRTC = false;&#xA;readonly b NTP = true;&#xA;readonly b NTPSynchronized = true;&#xA;readonly t TimeUSec = 1467291739170844;&#xA;readonly t RTCTimeUSec = 1467291739000000;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Timezone&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;时区列表是由 &lt;code&gt;tzdata&lt;/code&gt; 这个包提供的, 安装在 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; 下面.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有些地方为了节约能源, 在夏天时会把时间调慢. 当时区中有夏令时系统会自动调整时间.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;zdump&lt;/code&gt; 命令可以查看时区的详细信息, 如查询 &lt;code&gt;America/New_York&lt;/code&gt; 的夏令时时区信息：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~  zdump -v -c 2016,2017 America/New_York&#xA;America/New_York  Sun Mar 13 06:59:59 2016 UT = Sun Mar 13 01:59:59 2016 EST isdst=0 gmtoff=-18000&#xA;America/New_York  Sun Mar 13 07:00:00 2016 UT = Sun Mar 13 03:00:00 2016 EDT isdst=1 gmtoff=-14400&#xA;America/New_York  Sun Nov  6 05:59:59 2016 UT = Sun Nov  6 01:59:59 2016 EDT isdst=1 gmtoff=-14400&#xA;America/New_York  Sun Nov  6 06:00:00 2016 UT = Sun Nov  6 01:00:00 2016 EST isdst=0 gmtoff=-18000&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中 &lt;code&gt;isdst=1&lt;/code&gt; 就表示夏令时被启用.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>修复 superblock</title>
      <link>http://45.62.229.81:8080/Blog/%E4%BF%AE%E5%A4%8D-superblock/</link>
      <pubDate>2018-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本周去某公司调试系统，他们硬件测试部分送来了一台系统无法进入的机器，他们也不知道怎么弄得，让我看下是系统原因还是 &lt;code&gt;SSD&lt;/code&gt; 硬件有问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;拿到机器开机后，没有正常的进入系统，直接进入了&lt;code&gt;initramfs mode&lt;/code&gt; 并有&lt;code&gt;filesystem invalid superblock checksum error&lt;/code&gt; 的错误提示，遂告诉他们是系统的 &lt;code&gt;filesystem&lt;/code&gt; 挂了，然后开始查找修复方法，最后找到了方法并修复了机器，在此记录一下。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;修复方法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;下面的命令都是在&lt;code&gt;initramfs shell&lt;/code&gt;中执行的。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;先确定你系统所在的分区&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;可以执行 &lt;code&gt;lsblk&lt;/code&gt; 来查看分区信息，然后确定，假如是 &lt;code&gt;/dev/sdaX&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;列出分区的&lt;code&gt;superblock&lt;/code&gt;备份信息&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;执行命令 &lt;code&gt;mke2fs -n /dev/sdaX&lt;/code&gt;，将会看到以下输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mke2fs 1.44.2 (14-May-2018)&#xA;&#xA;/dev/sda7 有一个 ext4 文件系统&#xA;&#xA;    上一次挂载于 /， 时间 Thu May 17 17:15:32 2018&#xA;&#xA;Proceed anyway? (y,N) y&#xA;&#xA;创建含有 7864320 个块（每块 4k）和 1966080 个inode的文件系统&#xA;&#xA;文件系统UUID：dd407bb8-e38a-42f8-ae3f-38081af46323&#xA;&#xA;超级块的备份存储于下列块：&#xA;&#xA;    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,&#xA;&#xA;4096000&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;从备份中恢复&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;先使用备份中列块的第一个 &lt;code&gt;number&lt;/code&gt; 进行恢复，命令：&lt;code&gt;e2fsck -b 32768 /dev/sdaX -y&lt;/code&gt;, 执行完成后重启。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果重启还是进不了系统，就换一个 &lt;code&gt;列块 number&lt;/code&gt; 继续恢复，然后重启，直至成功。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>RESTfull 简介</title>
      <link>http://45.62.229.81:8080/Blog/RESTfull-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>2018-05-10 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;RESTfull&lt;/code&gt; 即表现层状态转换，是一种设计风格，不是标准。其要点如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;资源由 &lt;code&gt;URI&lt;/code&gt; 来指定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;每个资源都有与之对应的 &lt;code&gt;URI&lt;/code&gt;，一个 &lt;code&gt;URI&lt;/code&gt; 只能对应一种资源，但一种资源可以对应多个 &lt;code&gt;URI&lt;/code&gt;(不同的分类方法)。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对资源的操作对应到 &lt;code&gt;HTTP&lt;/code&gt; 协议提供的方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如增删改查等操作，对应 &lt;code&gt;HTTP&lt;/code&gt; 协议的 &lt;code&gt;POST, DELETE, PUT, GET&lt;/code&gt; 等方法&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;资源的表现形式通常广泛流行的协议和标准&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如 &lt;code&gt;JSON, XML, HTML&lt;/code&gt; 等格式，当然也可以是其它格式或者私有格式，但一定足够能描述自己&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过操作资源的表现形式来操作资源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;通过修改表现形式再辅以 &lt;code&gt;HTTP&lt;/code&gt; 协议的方法，应用就可以管理资源&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以超媒体作为应用状态的引擎&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;资源相关操作的 &lt;code&gt;URI&lt;/code&gt; 可附加在表现形式内，应用根据自身状态选择相应的 &lt;code&gt;URI&lt;/code&gt; 来更改状态。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;操作可以是 &lt;code&gt;URI&lt;/code&gt; 外，也可以是一段代码，让应用执行。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;总结起来就是：通过改变资源的表现形式来更改资源状态，以表现形式里的超媒体信息来引导应用的状态改变。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在很多设计只用到了 &lt;strong&gt;资源 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;HTTP&lt;/code&gt;动词&lt;/strong&gt; 的方式，但 &lt;strong&gt;超媒体&lt;/strong&gt; 不容忽视，是与应用交互的核心。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;HTTP&lt;/code&gt; 方法使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;下面介绍几种常用的 &lt;code&gt;HTTP&lt;/code&gt; 协议方法:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;POST&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用于资源的添加&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DELETE&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用于资源的删除&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PUT&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用于修改资源，需要提供完整的资源信息，可用于修改资源多项字段&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GET&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用于资源的获取&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PATCH&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;用于修改资源的单个字段&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;示例&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;如构建一个用户信息服务，&lt;code&gt;API&lt;/code&gt; 按照 &lt;code&gt;RESTfull&lt;/code&gt; 风格可设计如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[POST] /users/:user&lt;/code&gt; 添加用户&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[DELETE] /users/:user&lt;/code&gt; 删除用户&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[PUT] /users/:user&lt;/code&gt; 修改用户整体信息&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[PATCH] /users/:user&lt;/code&gt; 修改用户的单个字段&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[GET] /users/:user&lt;/code&gt; 获取用户信息&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;[GET] /users&lt;/code&gt; 获取所有用户信息&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;另外在 &lt;code&gt;GET&lt;/code&gt; 的信息中加入 &lt;code&gt;DELETE, PUT, PATCH&lt;/code&gt; 的 &lt;code&gt;URI&lt;/code&gt;，应用就可以根据这些 &lt;code&gt;URI&lt;/code&gt; 显示可以进行的操作，动态的生成页面。&#xA;此种方法也减少了耦合，避免了 &lt;code&gt;URI&lt;/code&gt; 变更时大量的修改。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;尽管上面的描述很简单，但也能发现采用 &lt;code&gt;RESTfull&lt;/code&gt; 来设计 &lt;code&gt;Web API&lt;/code&gt; 是一种简洁明了的方案，通过与 &lt;code&gt;HTTP&lt;/code&gt; 动词结合，避免了在 &lt;code&gt;URI&lt;/code&gt; 中设置大量动词的问题，需要关注的只是对资源的抽象和划分。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本文到此为止，关于 &lt;code&gt;RESTfull&lt;/code&gt; 更多更详尽的内容请自行查找。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考文档&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/rest-introduction&#34;&gt;深入浅出REST&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/09/restful.html&#34;&gt;理解RESTful架构&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/05/restful_api.html&#34;&gt;RESTful API 设计指南&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html&#34;&gt;Restful API 的设计规范&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Git Rebase 回退</title>
      <link>http://45.62.229.81:8080/Blog/Git-Rebase-%E5%9B%9E%E9%80%80/</link>
      <pubDate>2018-04-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在开发新功能或修复 &lt;code&gt;bug&lt;/code&gt; 时，一般需要新建一个分支，然后在它之上进行开发。在多人协同开发时，经常会同时修改相同的分支或相同的文件，这时就需要进行 &lt;code&gt;rebase&lt;/code&gt; 操作在提交你的代码之前。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但有时 &lt;code&gt;rebase&lt;/code&gt; 会带来不想要的提交，或处理冲突时误操作执行了 &lt;code&gt;git rebase --skip&lt;/code&gt; 。此时就想要回退到之前的提交，恢复自己的数据，&lt;code&gt;reflog&lt;/code&gt; 就可以帮助你完成数据恢复。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;reflog&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当你工作时，&lt;code&gt;Git&lt;/code&gt; 会在你每次修改了 &lt;code&gt;HEAD&lt;/code&gt; 时悄悄地将改动记录下来。当你提交或修改分支时，&lt;code&gt;reflog&lt;/code&gt; 就会更新。通过 &lt;code&gt;git reflog&lt;/code&gt; 命令可以查看当前的状态：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;7115aff (HEAD -&amp;gt; master, tag: 3.1.21, origin/master, origin/HEAD) HEAD@{0}: pull: Fast-forward&#xA;c0a16ee HEAD@{1}: pull: Fast-forward&#xA;abf0bfb (tag: 3.1.20) HEAD@{2}: pull: Fast-forward&#xA;c469d2c HEAD@{3}: pull: Fast-forward&#xA;9148742 HEAD@{4}: pull: Fast-forward&#xA;0dc73dd HEAD@{5}: pull: Fast-forward&#xA;4dea91e (gerrit/master) HEAD@{6}: checkout: moving from rename-mousearea to master&#xA;0dc73dd HEAD@{7}: reset: moving to 0dc73ddd5f28118c428cfb952a5cfea557239aef&#xA;0dc73dd HEAD@{8}: rebase -i (finish): returning to refs/heads/rename-mousearea&#xA;0dc73dd HEAD@{9}: rebase -i (pick): updating HEAD&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;找到你提交所在的 &lt;code&gt;HEAD&lt;/code&gt; 后，如 &lt;code&gt;HEAD@{8}&lt;/code&gt; ，就可以用命令下面的命令来恢复你的代码了：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;git reset --hard HEAD@{8}&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同样这种方法也适用与其它的 &lt;code&gt;Git&lt;/code&gt; 误操作。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>CUPS 资料</title>
      <link>http://45.62.229.81:8080/Blog/CUPS-%E8%B5%84%E6%96%99/</link>
      <pubDate>2018-04-08 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Installation&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo apt install cups ghostscript gsfonts&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Driver&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gutenprint&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一组质量非常好的驱动集合，支持的目标机型包括 Canon, Epson, Lexmark, Sony, Olympus；以及配合CUPS/GhostSscript/Foomatic/GIMP使用的 PCL printers。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;cups-driver-gutenprint gimp-gutenprint ijsgutenprint printer-driver-gutenprint&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;foomatic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Foomatic 是一个基于数据库的，集成自由软件打印机驱动和脱机打印程序的系统。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;foomatic-db foomatic-db-engine foomatic-db-compressed-ppds foomatic-db-gutenprint foomatic-filters&lt;/code&gt; 以及 &lt;code&gt;foomatic-db-nonfree&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;foo2zjs&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Drivers for ZjStream protocol printers such as the HP Laserjet 1018.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;printer-driver-foo2zjs&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;hplip&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HP GNU/Linux 驱动. 支持 DeskJet, OfficeJet, Photosmart, Business Inkjet 和一些 LaserJet printer 型的, 以及一些兄弟打印机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;hplip hplip-gui hplip-plugin&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;splix&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;三星驱动，支持SPL打印机(SPL：Samsung Printer Language)  (USB打印机要配合 cups-usblp 使用)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;printer-driver-splix splix samsung-printers samsung-print firmware-samsung&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cndrvcups&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;佳能 UFR2 驱动，支持LBP, iR 和 MF 系列打印机.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装包: &lt;code&gt;cndrvcups-capt cndrvcups-ufr2-uk cndrvcups-ufr2lt-uk cndrvcups-utility&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cups-pdf&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;PDF虚拟打印机，这个东西可以把发送给他的打印任务输出为PDF文件。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这些驱动可以全部预装。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有些打印机需要 &lt;code&gt;PPD&lt;/code&gt; 文件，上面的驱动会自带一部分，如果没有就需要去查找了：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;到源里查找，包括其他发行版，如 &lt;a href=&#34;https://wiki.archlinux.org/index.php/AUR&#34;&gt;aur&lt;/a&gt; 中找&lt;/li&gt;&#xA;&lt;li&gt;到 &lt;a href=&#34;http://www.openprinting.org/printers&#34;&gt; OpenPrinting database&lt;/a&gt; 选择制造商和型号&lt;/li&gt;&#xA;&lt;li&gt;到制造商官网查找&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Configuration&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;配置文件在 &lt;code&gt;/etc/cups&lt;/code&gt; 这个目录，为了方便排错，建议把 &lt;code&gt;/etc/cups/cupsd.conf&lt;/code&gt; 中 &lt;code&gt;LogLevel&lt;/code&gt; 设置为 &lt;code&gt;debug2&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;USB 打印机&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;lsusb&lt;/code&gt; 查看设备。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要加载模块 &lt;code&gt;usbcore&lt;/code&gt;, 有的打印机还需要加载 &lt;code&gt;usblp&lt;/code&gt; 而有的需要把它屏蔽&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;并口打印机&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;sudo dmesg | grep -i parport&lt;/code&gt; 查看设备&lt;/p&gt;&#xA;&#xA;&lt;p&gt;需要加载模块 &lt;code&gt;lp parport parport_pc&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;有些使用 &lt;code&gt;usb to parallel&lt;/code&gt; 的打印机可能无法识别，需要使用不同的连接方式，并将 &lt;code&gt;DeviceID&lt;/code&gt; 写入到文件 &lt;code&gt;/etc/cups/printers.conf&lt;/code&gt;，如 &lt;code&gt;DeviceID = parallel:/dev/usb/lp0&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Links&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/CUPS&#34;&gt;Arch Wiki CUPS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/CUPS/Troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/CUPS/Printer-specific_problems&#34;&gt;Arch Printer Driver&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://wiki.deepin.org/index.php?title=%E6%89%93%E5%8D%B0%E6%9C%BA&#34;&gt;Deepin Wiki CUPS&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Bluetooth FAQ</title>
      <link>http://45.62.229.81:8080/Blog/Bluetooth-FAQ/</link>
      <pubDate>2017-11-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;收集遇到的 &lt;code&gt;bluetooth&lt;/code&gt; 问题，使用的是 &lt;code&gt;deepin&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;控制中心不显示蓝牙模块&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;蓝牙模块不显示时，可以按照以下步骤来查找原因：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;sudo dmesg|grub bluetooth&lt;/code&gt; 查看输出结果&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;输出里有 &lt;code&gt;timeout&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此时再用 &lt;code&gt;systemctl status bluetooth.service&lt;/code&gt; 看下服务有没有正常启动，错误信息是什么，然后根据错误去网上搜索答案。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果蓝牙是由网卡提供的，此时可以试着开关一下网卡的硬件开关。因为内核在初始化网卡之前初始化蓝牙，就会导致蓝牙设备不可用，重新初始化一次就好了。&#xA;如果还是无效那就重启进入 &lt;code&gt;window&lt;/code&gt;，再 &lt;code&gt;window&lt;/code&gt; 里开关一次蓝牙再重启到 &lt;code&gt;linux&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;输出里无 &lt;code&gt;timeout&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这就表明初始化没问题，继续下一步&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;sudo hciconfig&lt;/code&gt; 查看设备当前的状态&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;状态为 &lt;code&gt;DOWN&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;则执行 &lt;code&gt;sudo hciconfig hci&amp;lt;number&amp;gt; up&lt;/code&gt;，其中 &lt;strong&gt;number&lt;/strong&gt; 为前面输出显示的。&#xA;如果命令执行失败，参照第一步。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;状态为 &lt;code&gt;UP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;继续下一步&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;sudo rfkill list&lt;/code&gt; 查看设备是否被 &lt;code&gt;block&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;被 &lt;code&gt;block&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;则执行 &lt;code&gt;sudo rfkill &amp;lt;dev&amp;gt; unblock&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如果尝试完上述步骤，蓝牙仍不可用，那就反馈吧，提供日志及 &lt;code&gt;lsusb&lt;/code&gt; 输出，等待问题被解决。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;蓝牙鼠标使用中频繁断开&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;蓝牙鼠标在使用过程中频繁出现了断开问题，应在断开后执行 &lt;code&gt;sudo dmesg&lt;/code&gt; 来查看是否有错误，如果没有错误信息，那就反馈吧。&#xA;如果出现 &lt;code&gt;firmware&lt;/code&gt; 加载失败，记住这个固件名。试着从 &lt;code&gt;window&lt;/code&gt; 那里获取最新的驱动，然后转成 &lt;code&gt;linux firmware&lt;/code&gt;，方法如下:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;查找并下载本机蓝牙适配器的驱动，一般可在笔记本或蓝牙适配器的官网下载到&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;然后解压，如果是 &lt;code&gt;.exe&lt;/code&gt; 文件就安装 &lt;code&gt;innoextract&lt;/code&gt; 来解压&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;然后查看驱动信息的 &lt;code&gt;.inf&lt;/code&gt; 文件，比如 &lt;code&gt;thinkpad x230 win8 64&lt;/code&gt; 的文件就是 &lt;code&gt;app/Win64/bcbtums-win8x64-brcm.inf&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;lsusb&lt;/code&gt; 获取蓝牙设备的 &lt;code&gt;ID&lt;/code&gt;。如 &lt;code&gt;x230&lt;/code&gt; 即是 &lt;code&gt;ID 0a5c:21e6 Broadcom Corp. BCM20702 Bluetooth 4.0 [ThinkPad]&lt;/code&gt;，然后搜索 &lt;code&gt;0a5c 21e6&lt;/code&gt; 相关的内容，找到对应的 &lt;code&gt;.hex&lt;/code&gt; 文件。如 &lt;code&gt;x230&lt;/code&gt; 即是 &lt;code&gt;BCM20702A1_001.002.014.1443.1453.hex&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;hex2hcd xxx.hex&lt;/code&gt; 将 &lt;code&gt;xxx.hex&lt;/code&gt; 转为 &lt;code&gt;.hcd&lt;/code&gt; 文件，然后重命名为缺失的固件名，复制到 &lt;code&gt;/lib/firmware/&lt;/code&gt; 下对应的位置&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;蓝牙音箱/耳机连上就断开&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;蓝牙音箱如果断开，先按照蓝牙耳机的方法试一下。如果不是，那就考虑是不是电脑的蓝牙不支持蓝牙高保真输出，因为 &lt;code&gt;deepin&lt;/code&gt; 默认开启高保真。&#xA;试着安装 &lt;code&gt;pavucontrol&lt;/code&gt; 将蓝牙的 &lt;code&gt;profile(配置)&lt;/code&gt; 切换为其它的，不过这样会导致音效很差，建议换掉电脑的蓝牙设备吧。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>设置 Grub2 分辨率</title>
      <link>http://45.62.229.81:8080/Blog/%E8%AE%BE%E7%BD%AE-Grub2-%E5%88%86%E8%BE%A8%E7%8E%87/</link>
      <pubDate>2017-07-29 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;平时经常用显示器的分辨率去设置 &lt;code&gt;Grub&lt;/code&gt; 的分辨率，虽然大部分都没有问题，但有时却没有用。所以就把 &lt;code&gt;Grub&lt;/code&gt; 分辨率的设置方法详细说明一下，留档记录。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;查询支持的分辨率&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在设置 &lt;code&gt;Grub&lt;/code&gt; 分辨率之前，需要先知道支持的分辨率列表，而幸运的是可以到 &lt;code&gt;Grub&lt;/code&gt; 命令行查询。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;进入 &lt;code&gt;Grub&lt;/code&gt; 命令行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在 &lt;code&gt;Grub&lt;/code&gt; 启动界面，按下 &lt;code&gt;c&lt;/code&gt; 键就可以进入命令行界面了。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询支持的分辨率&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在命令行界面输入 &lt;code&gt;videoinfo&lt;/code&gt; 就可以得到支持的分辨率列表。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;测试效果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;可以在命令行下输入 &lt;code&gt;terminal_output console&lt;/code&gt; 进入终端模式，然后输入 &lt;code&gt;set gfxmode=&amp;lt;分辨率&amp;gt;&lt;/code&gt; 设置要测试的分辨率，然后查看效果。&#xA;测试完后输入 &lt;code&gt;terminal_output gfxterm&lt;/code&gt; 回到图形模式&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;找到合适的分辨率后，重启进入系统，然后开始设置分辨率。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;设置分辨率&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;启动菜单是在 &lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;，而这个文件是根据 &lt;code&gt;/etc/default/grub&lt;/code&gt; 里的配置生成的，所以修改分辨率时只需修改 &lt;code&gt;/etc/default/grub&lt;/code&gt; 这个文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;GRUB_GFXMODE&lt;/code&gt; 这个字段控制着分辨率，只需将它的值指定为上面找到的分辨率，然后用命令 &lt;code&gt;sudo grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt; 重新生成启动菜单即可。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>TCP BBR 设置及其增强版</title>
      <link>http://45.62.229.81:8080/Blog/TCP-BBR-%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%85%B6%E5%A2%9E%E5%BC%BA%E7%89%88/</link>
      <pubDate>2017-07-20 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;启用 BBR&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;BBR&lt;/code&gt; 是在 4.9 以后的内核才开始支持的, 可以试着执行 &lt;code&gt;sudo modprobe tcp_bbr&lt;/code&gt; 来确定是否支持, 没有输出就意味着支持, 将下面两行内容添加到 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件里开启用它:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;net.core.default_qdisc = fq&#xA;net.ipv4.tcp_congestion_control = bbr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;sysctl net.ipv4.tcp_available_congestion_control&lt;/code&gt; 查看支持的算法, 用&lt;code&gt;sysctl net.ipv4.tcp_congestion_control&lt;/code&gt; 查看当前使用的算法.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果这个模块不会自动加载, 需要把 &lt;code&gt;tcp_bbr_powered&lt;/code&gt; 添加到 &lt;code&gt;/etc/modules-load.d/modules.conf&lt;/code&gt; 中.&#xA;另外测试发现, 有时 &lt;code&gt;sysctl.conf&lt;/code&gt; 里的设置并不会应用, 需要手动执行一下, 因此便写了 &lt;code&gt;reload-sysctl.service&lt;/code&gt; 来做这个, &lt;code&gt;systemctl enable&lt;/code&gt; 这个服务后, 一切就 OK 了.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;使用增强版&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;个人电脑不建议使用增强版, 服务器上可以使用, 当然最终还是要根据两者的效果来选择.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;来源于: &lt;a href=&#34;https://moeclub.org/2017/06/24/278/&#34;&gt;Debian/Ubuntu TCP BBR 改进版/增强版&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Build&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Install&#xA;&lt;code&gt;shell&#xA;$ ./install.sh&#xA;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Clean&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rm Makefile tcp_bbr_powered.*&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;sysctl net.ipv4.tcp_available_congestion_control&lt;/code&gt; 查看支持的算法, 用&lt;code&gt;sysctl net.ipv4.tcp_congestion_control&lt;/code&gt; 查看当前使用的算法.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果这个模块不会自动加载, 需要把 &lt;code&gt;tcp_bbr_powered&lt;/code&gt; 添加到 &lt;code&gt;/etc/modules-load.d/modules.conf&lt;/code&gt; 中.&#xA;另外测试发现, 有时 &lt;code&gt;sysctl.conf&lt;/code&gt; 里的设置并不会应用, 需要手动执行一下, 因此便写了 &lt;code&gt;reload-sysctl.service&lt;/code&gt; 来做这个, &lt;code&gt;systemctl enable&lt;/code&gt; 这个服务后, 一切就 OK 了.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;附件&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;build.sh&#xA;```shell&#xA;wget --no-check-certificate -qO- &amp;lsquo;&lt;a href=&#34;https://moeclub.org/attachment/LinuxSoftware/bbr/tcp_bbr_powered.c.deb&#39;&#34;&gt;https://moeclub.org/attachment/LinuxSoftware/bbr/tcp_bbr_powered.c.deb&#39;&lt;/a&gt; &amp;gt;./tcp_bbr_powered.c&#xA;echo &amp;lsquo;obj-m:=tcp_bbr_powered.o&amp;rsquo; &amp;gt;./Makefile&#xA;echo &amp;lsquo;clean: &amp;lsquo; &amp;gt;&amp;gt; ./Makefile&#xA;echo -e &amp;lsquo;\trm -r Module.symvers modules.order tcp_bbr_powered.mod.* tcp_bbr_powered.o .tcp_bbr_powered.* .tmp_versions&amp;rsquo; &amp;gt;&amp;gt; ./Makefile&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;make -s -C /lib/modules/$(uname -r)/build M=&lt;code&gt;pwd&lt;/code&gt; modules CC=&lt;code&gt;which gcc&lt;/code&gt;&#xA;make clean&#xA;```&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;install.sh&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[ -f ./tcp_bbr_powered.ko ] &amp;amp;&amp;amp; [ -f /lib/modules/$(uname -r)/modules.dep ] &amp;amp;&amp;amp; {&#xA;cp -rf ./tcp_bbr_powered.ko /lib/modules/$(uname -r)/kernel/net/ipv4&#xA;depmod -a &amp;gt;/dev/null 2&amp;gt;&amp;amp;1                 &#xA;}                                         &#xA;&#xA;# configure&#xA;modprobe tcp_bbr_powered&#xA;[ ! -f /etc/sysctl.conf ] &amp;amp;&amp;amp; touch /etc/sysctl.conf                                 &#xA;sed -i &#39;/net.core.default_qdisc.*/d&#39; /etc/sysctl.conf                               &#xA;sed -i &#39;/net.ipv4.tcp_congestion_control.*/d&#39; /etc/sysctl.conf                      &#xA;echo &amp;quot;net.core.default_qdisc = fq&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf                               &#xA;echo &amp;quot;net.ipv4.tcp_congestion_control = bbr_powered&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf             &#xA;&#xA;lsmod |grep -q &#39;bbr_powered&#39;              &#xA;[ $? -eq &#39;0&#39; ] &amp;amp;&amp;amp; {                       &#xA;sysctl -p &amp;gt;/dev/null 2&amp;gt;&amp;amp;1                 &#xA;echo &amp;quot;Finish! &amp;quot;                           &#xA;exit 0                                    &#xA;} || {                                    &#xA;echo &amp;quot;Error, Loading BBR POWERED.&amp;quot;        &#xA;exit 1                                    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;reload-sysctl.service&#xA;```shell&#xA;[Unit]&#xA;Description=Reload sysctl&#xA;Before=network.target&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;[Service]&#xA;Type=simple&#xA;ExecStart=/usr/bin/sysctl -p&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[Install]&#xA;WantedBy=multi-user.target&#xA;```&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Leanote Install</title>
      <link>http://45.62.229.81:8080/Blog/Leanote-Install/</link>
      <pubDate>2017-07-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;Leanote&lt;/code&gt; 是一款开源的笔记软件, 支持使用 &lt;code&gt;markdown&lt;/code&gt; 来编辑笔记, 并可选择是否将笔记导出成博客, 这对于知识整理及写博客都是非常方便的, 故来尝试下.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Leanote&lt;/code&gt; 是使用 &lt;code&gt;Golang&lt;/code&gt; 编写的, 可以直接使用官方编译好的可执行文件.&#xA;另外它使用的是 &lt;code&gt;mongodb&lt;/code&gt; 数据库, 可以从源里安装, 也可以从官网下载.&#xA;以下的安装和配置都是基于最新的版本, 如果中途出错, 请看官方文档.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;Leanote&lt;/code&gt; 下载地址: &lt;a href=&#34;http://leanote.org/#download&#34;&gt;见这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;mongodb&lt;/code&gt; 下载地址: &lt;a href=&#34;https://www.mongodb.com/download-center&#34;&gt;见这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h3&gt;&lt;code&gt;Leanote&lt;/code&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;解压下载的文件, 然后进入 &lt;code&gt;Leanote&lt;/code&gt; 解压后的目录, 编辑 &lt;code&gt;conf/app.conf&lt;/code&gt;, 按需修改, 如 &lt;code&gt;site url, db user/passwd&lt;/code&gt; 等.&#xA;不过必须更改 &lt;code&gt;app.secret&lt;/code&gt;, 随意更改其中的几个字符即可.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;&lt;code&gt;mongodb&lt;/code&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;解压下载的文件后进入 &lt;code&gt;bin&lt;/code&gt; 目录, 然后执行 &lt;code&gt;./mongod --dbpath &amp;lt;data path&amp;gt;&lt;/code&gt; 来启动数据库, &lt;code&gt;data path&lt;/code&gt; 需要是绝对路径，要保证目录结构存在.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后另开一个终端来导入 &lt;code&gt;Leanote&lt;/code&gt; 的初始设置 &lt;code&gt;./mongorestore -h localhost -d leanote --dir &amp;lt;your leanote path&amp;gt;/mongodb_backup/leanote_install_data/&lt;/code&gt;.&#xA;导入完成后，为了安全性, 为 &lt;code&gt;leanote&lt;/code&gt; 数据库创建用户认证, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$&amp;gt;./mongo&#xA;&amp;gt; show dbs #　查看数据库&#xA;leanote 0.203125GB&#xA;local   0.078125GB&#xA;&amp;gt; use leanote # 切换到 leanote&#xA;switched to db leanote&#xA;&amp;gt; # 添加一个用户 root, 密码是 abc123&#xA;&amp;gt; db.createUser({&#xA;    user: &#39;root&#39;,&#xA;    pwd: &#39;abc123&#39;,&#xA;    roles: [{role: &#39;dbOwner&#39;, db: &#39;leanote&#39;}]&#xA;});&#xA;# 测试下是否正确&#xA;&amp;gt; db.auth(&amp;quot;root&amp;quot;, &amp;quot;abc123&amp;quot;);&#xA;1 # 返回 1 表示正确&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中密码中不要含有 &lt;code&gt;@&lt;/code&gt; 符号, 不然会连接数据库失败, 原因未知&amp;#x2026;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建了用户后, 需要在 &lt;code&gt;leanote/conf/app.conf&lt;/code&gt; 中填入. 这样就配置完成了, 可以执行 &lt;code&gt;leanote&lt;/code&gt; 下的 &lt;code&gt;bin/run.sh&lt;/code&gt; 来启动 &lt;code&gt;leanote&lt;/code&gt; 了.&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;账户管理&lt;/h2&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;默认提供了 &lt;code&gt;admin&lt;/code&gt; 和 &lt;code&gt;demo&lt;/code&gt; 账户, 使用 &lt;code&gt;conf/app.conf&lt;/code&gt; 里指定的管理员账户可以更改 &lt;code&gt;leanote&lt;/code&gt; 的设置(如: 首页设置, 开放注册等)以及更改用户的密码.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外可以直接操作数据库来管理用户, 下面介绍下如何创建, 更改以及删除用户, 更多操作请查看 &lt;a href=&#34;http://docs.mongoing.com/manual-zh/crud.html&#34;&gt;mongodb 文档&lt;/a&gt; .&#xA;数据库名为 &lt;code&gt;leanote&lt;/code&gt;, 账户表名为 &lt;code&gt;users&lt;/code&gt; , 使用 &lt;code&gt;db.users.find()&lt;/code&gt; 可以看到表中所有的记录 .&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;创建账户&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;新建的账户名为 &lt;code&gt;test1&lt;/code&gt;, 邮箱为 &lt;code&gt;test1@gmail.com&lt;/code&gt;, 密码由于是加密的, 就不在这里设置, 通过管理员到界面上去重置密码.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; use leanote&#xA;&amp;gt; db.users.insert({&amp;quot;Username&amp;quot;: &amp;quot;test1&amp;quot;, &amp;quot;Email&amp;quot;: &amp;quot;test1@gmail.com&amp;quot;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;更改&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如更改 &lt;code&gt;admin&lt;/code&gt; 名为 &lt;code&gt;root&lt;/code&gt;, 更改了 &lt;code&gt;admin&lt;/code&gt; 后也需要到 &lt;code&gt;&amp;lt;leanote path&amp;gt;/conf/app.conf&lt;/code&gt; 去更改管理员的名称, 如果设置了的话.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; use leanote&#xA;&amp;gt; db.users.updateOne({&amp;quot;Username&amp;quot;: &amp;quot;admin&amp;quot;}, {$set: {&amp;quot;Username&amp;quot;: &amp;quot;root&amp;quot;}})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;删除&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如删除 &lt;code&gt;demon&lt;/code&gt; 用户&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; use leanote&#xA;&amp;gt; db.users.remove({&amp;quot;Username&amp;quot;: &amp;quot;demo&amp;quot;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN Install</title>
      <link>http://45.62.229.81:8080/Blog/OpenVPN-Install/</link>
      <pubDate>2016-12-27 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;安装所需软件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Arch: &lt;code&gt;yaourt -S openvpn easy-rsa&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;生成证书&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Server 端&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Copy template file&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo mkdir -p /etc/openvpn&#xA;sudo cp -R /etc/easy-rsa /etc/openvpn&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Config vars&#xA;取消并修改以下项:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;set_var EASYRSA_REQ_COUNTRY     &amp;quot;CN&amp;quot;&#xA;set_var EASYRSA_REQ_PROVINCE    &amp;quot;Hongkong&amp;quot;&#xA;set_var EASYRSA_REQ_CITY        &amp;quot;Hongkong&amp;quot;&#xA;set_var EASYRSA_REQ_ORG         &amp;quot;jouyouyun.info&amp;quot;&#xA;set_var EASYRSA_REQ_EMAIL       &amp;quot;wen@jouyouyun.iofn&amp;quot;&#xA;set_var EASYRSA_REQ_OU          &amp;quot;Jouyouyun OpenVPN&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建根证书&#xA;&lt;code&gt;ca&lt;/code&gt; 证书需要输入密码，这个密码是给服务器端和客户端签名时用的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa init-pki&#xA;easyrsa build-ca&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建并签名服务器端证书&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-req &amp;lt;server name&amp;gt; nopass&#xA;easyrsa sign server &amp;lt;server name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建Diffie-Hellman证书&#xA;该证书主要作用是确保共享KEY安全穿越不安全网络&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建并签名客户端证书&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-req &amp;lt;client name&amp;gt; nopass&#xA;easyrsa sign client &amp;lt;client name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;配置服务器端&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;复制一份模板文件(&lt;code&gt;/usr/share/openvpn/examples/server.conf&lt;/code&gt;)到 &lt;code&gt;/etc/openvpn&lt;/code&gt; 目录, 然后开始修改相关项.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后将证书文件放在 &lt;code&gt;/etc/openvpn&lt;/code&gt; 目录下, 需要的文件包括:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easy-rsa/pki/ca.crt&#xA;easy-rsa/pki/dh.pem&#xA;easy-rsa/pki/issued/&amp;lt;server name&amp;gt;.crt&#xA;easy-rsa/pki/private/&amp;lt;server name&amp;gt;.key&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;配置客户端&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;复制一份模板文件 &lt;code&gt;/usr/share/openvpn/examples/client.conf&lt;/code&gt;, 然后开始修改相关项.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将以下证书文件与配置文件放在一起, 需要的文件包括:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easy-rsa/pki/ca.crt&#xA;easy-rsa/pki/issued/&amp;lt;client name&amp;gt;.crt&#xA;easy-rsa/pki/private/&amp;lt;client name&amp;gt;.key&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;开启路由转发&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sed -i &#39;/net.ipv4.ip_forward/s/0/1/&#39; /etc/sysctl.conf&#xA;sysctl -p&#xA;# 允许vpn客户端所在网段流量转发到其它网卡&#xA;iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT&#xA;# 将vpn客户端的流量转到eth0，允许vpn客户端上网，即NAT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j  MASQUERADE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;示例&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;认证可以通过证书认证也可以使用用户名密码认证，推荐使用用户名密码认证, 这样方便添加用户.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;证书认证&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;port 1194&#xA;proto tcp&#xA;dev tun&#xA;&#xA;ca /etc/openvpn/ca.crt&#xA;cert /etc/openvpn/server.crt&#xA;key /etc/openvpn/server.key&#xA;dh /etc/openvpn/dh.pem&#xA;&#xA;server 10.8.0.0 255.255.255.0&#xA;ifconfig-pool-persist /etc/openvpn/ipp.txt&#xA;push &amp;quot;redirect-gateway def1 bypass-dhcp&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;&#xA;client-to-client&#xA;keepalive 10 120&#xA;cipher AES-256-CBC&#xA;;comp-lzo # 禁用压缩，如果开启客户端配置中也需要开启&#xA;max-clients 100&#xA;persist-key&#xA;persist-tun&#xA;&#xA;status /var/log/openvpn/openvpn-status.log&#xA;log         /var/log/openvpn/openvpn.log&#xA;log-append  /var/log/openvpn/openvpn.log&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;client&#xA;dev tun&#xA;proto tcp&#xA;&#xA;resolv-retry infinite&#xA;remote &amp;lt;your vps ip&amp;gt; 1194&#xA;nobind&#xA;&#xA;persist-key&#xA;persist-tun&#xA;&#xA;ca ca.crt&#xA;cert client.crt&#xA;key client.key&#xA;&#xA;cipher AES-256-CBC&#xA;#comp-lzo&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;用户名密码认证&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;需要加入auth-user-pass-verify，开启用户密码脚本, 脚本示例, 读取 &lt;code&gt;/etc/openvpn/passwd&lt;/code&gt; 文件:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh&#xA;###########################################################&#xA;# checkpsw.sh (C) 2004 Mathias Sundman &amp;lt;mathias@openvpn.se&amp;gt;&#xA;#&#xA;# This script will authenticate OpenVPN users against&#xA;# a plain text file. The passfile should simply contain&#xA;# one row per user with the username first followed by&#xA;# one or more space(s) or tab(s) and then the password.&#xA;&#xA;PASSFILE=&amp;quot;/etc/openvpn/passwd&amp;quot;&#xA;LOG_FILE=&amp;quot;/var/log/openvpn/openvpn-password.log&amp;quot;&#xA;TIME_STAMP=`date &amp;quot;+%Y-%m-%d %T&amp;quot;`&#xA;&#xA;###########################################################&#xA;&#xA;if [ ! -r &amp;quot;${PASSFILE}&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: Could not open password file \&amp;quot;${PASSFILE}\&amp;quot; for reading.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 1&#xA;fi&#xA;&#xA;CORRECT_PASSWORD=`awk &#39;!/^;/&amp;amp;&amp;amp;!/^#/&amp;amp;&amp;amp;$1==&amp;quot;&#39;${username}&#39;&amp;quot;{print $2;exit}&#39; ${PASSFILE}`&#xA;&#xA;if [ &amp;quot;${CORRECT_PASSWORD}&amp;quot; = &amp;quot;&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: User does not exist: username=\&amp;quot;${username}\&amp;quot;, password=\&amp;quot;${password}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 1&#xA;fi&#xA;&#xA;if [ &amp;quot;${password}&amp;quot; = &amp;quot;${CORRECT_PASSWORD}&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: Successful authentication: username=\&amp;quot;${username}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 0&#xA;fi&#xA;&#xA;echo &amp;quot;${TIME_STAMP}: Incorrect password: username=\&amp;quot;${username}\&amp;quot;, password=\&amp;quot;${password}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;exit 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;port 1194&#xA;proto tcp&#xA;dev tap&#xA;&#xA;#不要求客户端有证书&#xA;client-cert-not-required&#xA;username-as-common-name&#xA;&#xA;script-security 3 system&#xA;#使用脚本验证密码&#xA;auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env&#xA;&#xA;ca   /etc/openvpn/keys/ca.crt&#xA;cert /etc/openvpn/keys/server.crt&#xA;key  /etc/openvpn/keys/server.key&#xA;dh   /etc/openvpn/keys/dh1024.pem&#xA;&#xA;server 10.8.6.0 255.255.255.0&#xA;&#xA;#保存已有的用户和ip的对应关系&#xA;ifconfig-pool-persist ipp.txt&#xA;&#xA;#允许客户端之间互访&#xA;client-to-client&#xA;&#xA;keepalive 10 120&#xA;&#xA;user nobody&#xA;group nogroup&#xA;&#xA;persist-key&#xA;persist-tun&#xA;&#xA;#保存日志&#xA;status openvpn-status.log&#xA;#日志冗余级别&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;客户端配置文件中去掉于证书相关的配置，加入 &lt;code&gt;auth-user-pass&lt;/code&gt; 打开用户名密码验证.&#xA;可以加入auth-nocache可以在断线后防止内存中保存用户名和密码来提高安全性。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-24250828-id-3536671.html&#34;&gt; Linux 下OpenVPN 密钥认证 和 用户名/密码认证 笔记&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>MIME Usage</title>
      <link>http://45.62.229.81:8080/Blog/MIME-Usage/</link>
      <pubDate>2016-12-14 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;基本使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用到的工具为: xdg-mime, gvfs-mime&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询文件的类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;xdg-mime query filetype &amp;lt;filepath&amp;gt;&lt;/code&gt; 可以得到文件的类型&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询默认程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;xdg-mime query default text/plain&lt;/code&gt; 或 &lt;code&gt;gvfs-mime --query &amp;lt;mimetype&amp;gt;&lt;/code&gt;, &lt;code&gt;gvfs-mime&lt;/code&gt; 还会列出支持此 &lt;code&gt;mimetype&lt;/code&gt; 的所有程序&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置默认程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如将 &lt;code&gt;text/plain&lt;/code&gt; 的默认打开程序设置为 &lt;code&gt;gvim.desktop&lt;/code&gt;, 可以执行 &lt;code&gt;xdg-mime default gvim.desktop text/plain&lt;/code&gt; 或 &lt;code&gt;gvfs-mime --set text/plain gvim.desktop&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;根据文件扩展名指定类型&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;创建 &lt;code&gt;xml&lt;/code&gt; 文件, 指定类型, 如将 &lt;code&gt;*.org&lt;/code&gt; 指定为 &lt;code&gt;text/org-mode&lt;/code&gt;, 文件内容如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;&amp;lt;mime-info xmlns=&amp;quot;http://www.freedesktop.org/standards/shared-mime-info&amp;quot;&amp;gt;&#xA;  &amp;lt;mime-type type=&amp;quot;text/org-mode&amp;quot;&amp;gt;&#xA;         &amp;lt;comment xml:lang=&amp;quot;en&amp;quot;&amp;gt;Org-Mode File&amp;lt;/comment&amp;gt;&#xA;         &amp;lt;glob pattern=&amp;quot;*.org&amp;quot;/&amp;gt;&#xA;  &amp;lt;/mime-type&amp;gt;&#xA;&amp;lt;/mime-info&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将上面的 &lt;code&gt;xml&lt;/code&gt; 文件复制到 &lt;code&gt;$XDG_DATA_DIRS/mime/packages&lt;/code&gt; 中, 即文件要在 &lt;code&gt;~/.local/share/mime/packages, /usr/local/share/mime/packages, /usr/share/mime/packages&lt;/code&gt; 这几个目录中的一个&lt;/li&gt;&#xA;&lt;li&gt;执行 &lt;code&gt;update-mime-database &amp;lt;MIME DIR&amp;gt;&lt;/code&gt; 更新 &lt;code&gt;mime datebase&lt;/code&gt;, 上面的目录去掉 &lt;code&gt;packages&lt;/code&gt; 就是 &lt;code&gt;MIME DIR&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;这样 &lt;code&gt;*.org&lt;/code&gt; 的类型就变为 &lt;code&gt;text/org-mode&lt;/code&gt; 了, 参考 &lt;a href=&#34;https://freedesktop.org/wiki/Specifications/AddingMIMETutor/&#34;&gt;Add MIME Type&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>DDE Package List</title>
      <link>http://45.62.229.81:8080/Note/DDE-Package-List/</link>
      <pubDate>2016-08-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;现决定龙芯与专业版使用同一分支进行打包, 两者要保持版本一致, 对于需要特殊设置的地方, 请已 &lt;code&gt;patch&lt;/code&gt; 的方式存放到单独的仓库, 打包时去自动拉取.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;专业版桌面打包列表及分支(包名与仓库名系统的用 &lt;code&gt;-&lt;/code&gt; 表示, 仓库名没有的用 &lt;code&gt;?&lt;/code&gt; 表示):&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Package Name&lt;/th&gt;&#xA;&lt;th&gt;Repo Name&lt;/th&gt;&#xA;&lt;th&gt;Branch&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dbus-factory&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-control-center&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-daemon&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-desktop&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-dock&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-launcher&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-session-ui&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-desktop-schemas&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-desktop-base&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-mutter&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-file-manager-backend&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;golang-dlib-dev&lt;/td&gt;&#xA;&lt;td&gt;go-lib&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;go-gir-genrator&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-install&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-appstore&lt;/td&gt;&#xA;&lt;td&gt;dstore/deepin-appstore&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-default-settings&lt;/td&gt;&#xA;&lt;td&gt;default-settings&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-icon-theme&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-remote-assistance&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-tool-kit&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-license&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-help&lt;/td&gt;&#xA;&lt;td&gt;dde/dde-help&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde&lt;/td&gt;&#xA;&lt;td&gt;?&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;</description>
    </item>
    <item>
      <title>xrandr examples</title>
      <link>http://45.62.229.81:8080/Blog/xrandr-examples/</link>
      <pubDate>2016-06-06 04:52:30 +0800</pubDate>
      <description>&lt;p&gt;由于经常会用到使用 &lt;code&gt;xrandr&lt;/code&gt; 设置屏幕属性, 而每次用的时候都要去查 &lt;code&gt;man&lt;/code&gt; 手册, 有时还需要上网搜索例子.&#xA;这样一来就比较麻烦, 所以就想整理下 &lt;code&gt;xrandr&lt;/code&gt; 的用法, 给出一些常用的例子.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;查询&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;xrandr -q&lt;/code&gt; 命令可以查询当前的显示器状态, 使用 &lt;code&gt;xrandr --verbose&lt;/code&gt; 将会显示更详细的信息.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置分辨率时需要指定设置的 &lt;code&gt;ouput&lt;/code&gt; 以及 &lt;code&gt;mode&lt;/code&gt;, 如将 &lt;code&gt;eDP1&lt;/code&gt; 的分辨率改为 &lt;code&gt;1920x1080&lt;/code&gt;, 命令就是 &lt;code&gt;xrandr --output eDP1 --mode 1920x1080&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是单屏时不用这么麻烦, 可以直接使用命令 &lt;code&gt;xrandr -s 1920x1080&lt;/code&gt; 来更改.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;添加分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果 &lt;code&gt;xrandr -q&lt;/code&gt; 查询的结果中没有合适的分辨率, 则可以通过 &lt;code&gt;newmode&lt;/code&gt; 来添加一个, 下面将给出为 &lt;code&gt;eDP1&lt;/code&gt; 添加 &lt;code&gt;1440x900x60&lt;/code&gt; 的分辨率的方法.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;cvt&lt;/code&gt; 生成一个 &lt;code&gt;modeline&lt;/code&gt;, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;cvt 1440 900 60&#xA;# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz&#xA;Modeline &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;newmode&lt;/code&gt; 创建一个 &lt;code&gt;mode&lt;/code&gt;, 参数就是上面 &lt;code&gt;Modeline&lt;/code&gt; 后的内容, 命令如下:&#xA;&lt;code&gt;shell&#xA;-&amp;gt;xrandr --newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;将上面的 &lt;code&gt;mode&lt;/code&gt; 添加到 &lt;code&gt;eDP1&lt;/code&gt; 中:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;xrandr --addmode eDP1 1440x900_60.00&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果执行出错, 则说明不支持此模式. 如果没有错误则添加完成, 然后就可以设置此 &lt;code&gt;mode&lt;/code&gt; 为分辨率了.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;双屏配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如现在有两个 &lt;code&gt;output&lt;/code&gt;, 分别是 &lt;code&gt;eDP1&lt;/code&gt; 和 &lt;code&gt;VGA1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;设置主屏&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;通过指定 &lt;code&gt;--primary&lt;/code&gt; 参数来设置主屏, 如设置 &lt;code&gt;eDP1&lt;/code&gt; 为主屏: &lt;code&gt;xrandr --auto --output eDP1 --primary&lt;/code&gt;, &lt;code&gt;--auto&lt;/code&gt; 可以自动启用关闭的屏幕.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;复制模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;复制模式最好使用两个显示器都有的 &lt;code&gt;mode&lt;/code&gt; 作为默认的 &lt;code&gt;mode&lt;/code&gt;, 命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1440x900 --output VGA1 --same-as eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;扩展模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --mode 1440x900 --right-of eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;命令的结果就是 &lt;code&gt;VGA1&lt;/code&gt; 会在 &lt;code&gt;eDP1&lt;/code&gt; 的右边, &lt;code&gt;eDP1&lt;/code&gt; 为主屏, 另外位置的参数还有 &lt;code&gt;left-of&lt;/code&gt;, &lt;code&gt;--above&lt;/code&gt;, &lt;code&gt;--below&lt;/code&gt; 等.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果需要自定义两个屏幕的位置, 可以通过计算每个屏幕的分辨率, 用 &lt;code&gt;--pos&lt;/code&gt; 参数来指定每个屏幕显示的位置.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;单屏模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这个模式是只显示某一个屏幕, 如只显示 &lt;code&gt;eDP1&lt;/code&gt;, 可以使用命令 &lt;code&gt;xrandr --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --off&lt;/code&gt;,&#xA;这样就会把 &lt;code&gt;VGA1&lt;/code&gt; 给关闭.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;其它&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;另外屏幕的旋转, 镜像和缩放可以分别使用 &lt;code&gt;--rotate&lt;/code&gt;, &lt;code&gt;reflect&lt;/code&gt; 和 &lt;code&gt;--scale&lt;/code&gt; 参数来实现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至于更详细的信息请使用 &lt;code&gt;man xrandr&lt;/code&gt; 来查看.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Enable coredump</title>
      <link>http://45.62.229.81:8080/Note/Enable-coredump/</link>
      <pubDate>2016-04-25 07:04:33 +0800</pubDate>
      <description>&lt;h2&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当一个程序崩溃时会产生一个 &lt;code&gt;core&lt;/code&gt; 文件, 里面记录了这个程序崩溃的原因, 这些信息对于开发者是很有用的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是 &lt;code&gt;core dumps&lt;/code&gt; 在大多数 &lt;code&gt;linux&lt;/code&gt; 上是被禁用的, 下面就介绍下如何开启这个功能.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;开启&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;ulimit -c&lt;/code&gt; 的输出知道此功能是否开启, 输出为 &lt;code&gt;0&lt;/code&gt; 表示禁用, 否则为开启.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;临时开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通过 &lt;code&gt;ulimit -c unlimited&lt;/code&gt; 命令来开启 &lt;code&gt;coredump&lt;/code&gt; 功能, 它会程序运行的当前目录生成一个 &lt;code&gt;core&lt;/code&gt; 文件, 新的 &lt;code&gt;core&lt;/code&gt; 会覆盖旧的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过可以修改 &lt;code&gt;/proc/sys/kernel/core_uses_pid&lt;/code&gt; 文件内容为 &lt;code&gt;1&lt;/code&gt; 来生成以 &lt;code&gt;pid&lt;/code&gt; 作为扩展名的 &lt;code&gt;core&lt;/code&gt; 文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过修改 &lt;code&gt;/proc/sys/kernel/core_pattern&lt;/code&gt; 可以修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式. 如把内容改为 &lt;code&gt;/tmp/core-%e-%p-%t&lt;/code&gt;, 就表示把 &lt;code&gt;core&lt;/code&gt; 文件保存到 &lt;code&gt;/tmp&lt;/code&gt; 目录下, 文件名的格式为 &lt;code&gt;core-命令名-pid-时间戳&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;永久开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;首先把开启 &lt;code&gt;coredump&lt;/code&gt; 功能的命令 &lt;code&gt;ulimit -c unlimited &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 放到 &lt;code&gt;/etc/profile&lt;/code&gt; 中.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式, 在 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件中添加一下内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kernel.core_uses_pid = 1&#xA;kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改完 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 后, 执行 &lt;code&gt;sudo sysctl -p&lt;/code&gt; 重新加载配置.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;core pattern&lt;/code&gt; 说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;%% – A single % character&#xA;%p – PID of dumped process&#xA;%u – real UID of dumped process&#xA;%g – real GID of dumped process&#xA;%s – number of signal causing dump&#xA;%t – time of dump (seconds since 0:00h, 1 Jan 1970)&#xA;%h – hostname (same as ’nodename’ returned by uname(2))&#xA;%e – executable filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.linuxreviews.org/HOWTO_enable_core-dumps&#34;&gt;HOWTO enable core-dumps&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cyberciti.biz/tips/linux-core-dumps.html&#34;&gt;HowTo: Debug Crashed Linux Application Core Files&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Auto Hidden Cursor</title>
      <link>http://45.62.229.81:8080/Blog/Auto-Hidden-Cursor/</link>
      <pubDate>2016-04-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近需要做一个隐藏光标的功能, 在这里将了解到的知识总结一下.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标的原理就是把光标设置为一个 &lt;code&gt;x11 null cursor&lt;/code&gt;, 不需要隐藏时再将它设为 &lt;code&gt;x11 left_ptr cursor&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置光标主要需要调用下面两个函数:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int XDefineCursor(Display *display, Window w, Cursor cursor);&#xA;void XFixesChangeCursorByName (Display *dpy, Cursor source, const char *name);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;创建光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;至于创建 &lt;code&gt;null cursor&lt;/code&gt; 可以见下面的代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;window = DefaultRootWindow(display);&#xA;Cursor invisibleCursor;&#xA;Pixmap bitmapNoData;&#xA;XColor black;&#xA;static char noData[] = { 0,0,0,0,0,0,0,0 };&#xA;black.red = black.green = black.blue = 0;&#xA;bitmapNoData = XCreateBitmapFromData(display, window, noData, 8, 8);&#xA;invisibleCursor = XCreatePixmapCursor(display, bitmapNoData, bitmapNoData, &amp;amp;black, &amp;amp;black, 0, 0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;创建完后, 将其设置为默认光标就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外 &lt;code&gt;libxfixes&lt;/code&gt; 也提供了隐藏/显示光标的接口:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void XFixesHideCursor (Display *dpy, Window win);&#xA;void XFixesShowCursor (Display *dpy, Window win);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;其它&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标推荐使用 &lt;code&gt;unclutter&lt;/code&gt; 来设置, 它可以自定义空闲时间, 具体功能请见 &lt;code&gt;man&lt;/code&gt; 手册.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果使用 &lt;code&gt;lightdm&lt;/code&gt; 作为登录管理器, 可以编辑 &lt;code&gt;/etc/lightdm/lightdm.conf&lt;/code&gt; 文件,&#xA;在 &lt;code&gt;[Seat:*]&lt;/code&gt; 后添加 &lt;code&gt;xserver-command=X -bs -core -nocursor&lt;/code&gt;.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>debug 小结</title>
      <link>http://45.62.229.81:8080/Note/debug-%E5%B0%8F%E7%BB%93/</link>
      <pubDate>2016-02-03 03:06:35 +0800</pubDate>
      <description>&lt;p&gt;调试 &lt;code&gt;bug&lt;/code&gt; 的时候要有耐心, 要不断测试, 直到找到问题原因.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;确定 &lt;code&gt;bug&lt;/code&gt; 出现的方式&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一定要找到稳定重现的方式, 这样才能方便下面的调试&lt;/li&gt;&#xA;&lt;li&gt;如果找不到稳定重现的方法就只能根据上次出现的情形, 去查看相关的代码, 猜测可能出问题的地方, 然后针对那一块进行调试, 直到找到稳定重现方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;定位出问题的代码&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再找到稳定重现方式后, 开始定位出问题的函数, 然后加入调试信息, 不断尝试, 直到找到有问题的代码&lt;/li&gt;&#xA;&lt;li&gt;找到有问题的代码后, 如果发现是第三方库里的函数,可以打印出每次调用的输入输出参数, 看看是否有迹可循, 可以单独写个小程序, 传入问题的参数, 进行不断测试, 来确定第三方库有没有问题&lt;/li&gt;&#xA;&lt;li&gt;如果自己程序的代码, 就一行一行的慢慢测试, 确定问题的原因, 原因找到了就可以开始思考解决方法了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;修复 &lt;code&gt;bug&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;修复 &lt;code&gt;bug&lt;/code&gt; 时一定要仔细检查新添加的代码, 看看会不会造成其它的 &lt;code&gt;bug&lt;/code&gt;, 一定要不断测试, 把函数输入输出状态都打印出来, 以免出现界面是对的, 但函数的数据有误.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于开源的第三方库有问题时, 就把它的代码下下来, 加上调试信息后, 然后安装, 让你的程序使用自己编译的第三方库, 这样方便查找问题.&#xA;因为有时可能第三方库再使用时需要初始化一些资源, 而你使用的接口并没有做或少做了一点, 这样就导致你的程序出了问题.&#xA;这时就可以在程序中添加相关的初始化代码, 来处理这类问题, 这类问题一般第三方库升级时可能出现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若知道问题的原因后(这个原因一定要是相关低层的, 不能说是由于 A 调了 B , B 出问题了, 就把问题原因归与 A 的头上, 一定要是相当精确的), 不知道怎么修改, 这时就可以向组内成员求助, 或者去了解这方面的知识.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;性能调试工具&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于 &lt;code&gt;C/C++&lt;/code&gt; 代码, 可以使用 &lt;code&gt;Google Proftools&lt;/code&gt; 工具来调试. 它以程序调用的方式生成每次调用的性能消耗图, 方便定位占用资源多的函数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文档见: &lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/&#34;&gt;Google Proftools Documents&lt;/a&gt; , 使用方法自行 &lt;code&gt;google&lt;/code&gt; .&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;网站推荐&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;还可以去一些开发者网站提问:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.quora.com/&#34;&gt;国外的知乎: Quora&lt;/a&gt;&#xA;&lt;a href=&#34;http://segmentfault.com/&#34;&gt;SegmentFault&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者到 &lt;a href=&#34;http://www.ibm.com/developerworks/cn/&#34;&gt;IBM Developer&lt;/a&gt; 看写相关的技术文章, 前端的话还可以去 &lt;a href=&#34;https://developer.mozilla.org/&#34;&gt;Mozilla Developer&lt;/a&gt; .&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>xsetwacom 选项说明</title>
      <link>http://45.62.229.81:8080/Blog/xsetwacom-%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/</link>
      <pubDate>2016-02-03 02:58:29 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;xsetwacom&lt;/code&gt; 是一个设置数位板的命令行工具, 在 &lt;code&gt;Debian/Ubuntu/deepin&lt;/code&gt; 上可以通过安装 &lt;code&gt;xserver-xorg-input-wacom&lt;/code&gt; 来获取它.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;man xsetwacom&lt;/code&gt; 看到它的帮助文档, 下面就简单说明下它的部份选项:&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Options&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Area&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 x2 y2,&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板可使用的区域&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Button&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: button-number [mapping]&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔按钮的功能，可自定义为组合键，详细使用方法见文档&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;MapToOutput&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: output&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板与显示屏的映射，可以使用 &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;Head Number&lt;/code&gt;, &lt;code&gt;X11 geometry&lt;/code&gt; 三种方式设置&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;output: 如 &lt;code&gt;VGA1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Head Number: 通过 &lt;code&gt;XRandR extension&lt;/code&gt; 得到的&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;X11 geometry: 格式如 &lt;code&gt;WIDTHxHEIGHT+X+Y&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Mode&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: Absolute|Relative&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: Absolute&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置笔模式。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Absolute: 模式时数位笔对应的是数位板或屏幕的真实位置&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Relative: 模式时数位笔就像是一个鼠标&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;PressureCurve&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 100 100&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 压力曲线，(x1&lt;y1 x2&lt;y2) to &#34;soften&#34;，(x1&gt;y1 x2&amp;gt;y2) to &amp;ldquo;firmer&amp;rdquo;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;RawSample&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 20)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 4&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔原始采样率对应的窗口大小，不太清楚有什么用&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Rotate&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: none|half|cw|ccw&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: none&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置旋转度&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;none: 不旋转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;half: 上下翻转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;cw: 顺时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;ccw: 逆时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Suppress&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 100)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置移动灵敏度，值越大灵敏度越低&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Touch&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许触摸&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;HWTouchSwitchState&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许调节 &lt;code&gt;Touch&lt;/code&gt; 选项&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Threshold&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 2047)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 27&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置产生按键事件的最小力度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;其他&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于压力曲线，这里给出了一些测试值，从 &lt;code&gt;soften&lt;/code&gt; 到 &lt;code&gt;firmer&lt;/code&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0 100 0 100&lt;/li&gt;&#xA;&lt;li&gt;20 80 20 80&lt;/li&gt;&#xA;&lt;li&gt;30 70 30 70&lt;/li&gt;&#xA;&lt;li&gt;0 0 100 100&lt;/li&gt;&#xA;&lt;li&gt;60 40 60 40&lt;/li&gt;&#xA;&lt;li&gt;70 30 70 30&lt;/li&gt;&#xA;&lt;li&gt;75 25 75 25&lt;/li&gt;&#xA;&lt;li&gt;80 20 80 20&lt;/li&gt;&#xA;&lt;li&gt;90 10 90 10&lt;/li&gt;&#xA;&lt;li&gt;100 0 100 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 简单的 TCP Socket 示例</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--%E7%AE%80%E5%8D%95%E7%9A%84-TCP-Socket-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-07-20 12:54:43 +0800</pubDate>
      <description>&lt;p&gt;一个简单的 &lt;code&gt;TCP Socket&lt;/code&gt; 的示例，使用 &lt;code&gt;gob&lt;/code&gt; 处理传输的数据。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;server.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;const (&#xA;&#x9;BUF_SIZE = 1024&#xA;)&#xA;&#xA;func handleConnection(conn *net.TCPConn) {&#xA;&#x9;if conn == nil {&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;defer conn.Close()&#xA;&#xA;&#x9;data := make([]byte, BUF_SIZE)&#xA;&#x9;for {&#xA;&#x9;&#x9;n, err := conn.Read(data)&#xA;&#x9;&#x9;if err == io.EOF {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Read connection data failed:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Read %v byte data\n&amp;quot;, n)&#xA;&#xA;&#x9;&#x9;b := bytes.NewBuffer(data)&#xA;&#x9;&#x9;dec := gob.NewDecoder(b)&#xA;&#xA;&#x9;&#x9;info := personInfo{}&#xA;&#x9;&#x9;dec.Decode(&amp;amp;info)&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Server receive data: %v\n&amp;quot;, info)&#xA;&#x9;}&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;l, err := net.ListenTCP(&amp;quot;tcp&amp;quot;, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Listen port error:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;conn, err := l.AcceptTCP()&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;The client: %s connected\n&amp;quot;, conn.RemoteAddr().String())&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Accept error:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;go handleConnection(conn)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;client.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;&#x9;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;conn, err := net.DialTCP(&amp;quot;tcp&amp;quot;, nil, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Create connection failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;info := personInfo{&amp;quot;Maya&amp;quot;, 18, &amp;quot;13277085678&amp;quot;, &amp;quot;Hubei China&amp;quot;}&#xA;&#x9;var b bytes.Buffer&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;b)&#xA;&#x9;enc.Encode(&amp;amp;info)&#xA;&#x9;for {&#xA;&#x9;&#x9;conn.Write(b.Bytes())&#xA;&#x9;&#x9;fmt.Println(b.Bytes())&#xA;&#x9;&#x9;&amp;lt;-time.After(time.Second * 3)&#xA;&#x9;}&#xA;&#x9;conn.Close()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记：Gob Write/Read File</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0%EF%BC%9AGob-Write%2FRead-File/</link>
      <pubDate>2014-07-07 01:06:28 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;Gob&lt;/code&gt; 使用实例，将结构体写入文件里，在需要的时候再从文件中读取出来。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;type Writer struct {&#xA;&#x9;Id    int&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;type Reader struct {&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;func writeToFile(filename string, data interface{}) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;writeToFile filename invalid&amp;quot;)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;var w bytes.Buffer&#xA;&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;w)&#xA;&#x9;if err := enc.Encode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Encode data error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;if fp, err := os.Create(filename); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Open &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;} else {&#xA;&#x9;&#x9;defer fp.Close()&#xA;&#x9;&#x9;fp.WriteString(w.String())&#xA;&#x9;&#x9;fp.Sync()&#xA;&#x9;}&#xA;&#xA;&#x9;return true&#xA;}&#xA;&#xA;func readFromFile(filename string, data interface{}) {&#xA;&#x9;if len(filename) &amp;lt; 1 || data == nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;readFromFile args invalid&amp;quot;)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;ReadFile &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;r := bytes.NewBuffer(contents)&#xA;&#x9;dec := gob.NewDecoder(r)&#xA;&#xA;&#x9;if err := dec.Decode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Decode error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;wData := Writer{0, &amp;quot;firefox&amp;quot;, &amp;quot;Web Broswer&amp;quot;}&#xA;&#xA;&#x9;writeToFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;wData)&#xA;&#xA;&#x9;rData := Reader{}&#xA;&#x9;readFromFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;rData)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, rData)&#xA;&#xA;&#x9;// test map&#xA;&#x9;w := map[string]string{&#xA;&#x9;&#x9;&amp;quot;sublime-text&amp;quot;: &amp;quot;Sublime Text&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;firefox&amp;quot;:      &amp;quot;Web Broswer&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;terminator&amp;quot;:   &amp;quot;Terminator&amp;quot;,&#xA;&#x9;}&#xA;&#x9;writeToFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;w)&#xA;&#x9;r := make(map[string]string)&#xA;&#x9;readFromFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;r)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>chroot 脚本</title>
      <link>http://45.62.229.81:8080/Blog/chroot-%E8%84%9A%E6%9C%AC/</link>
      <pubDate>2014-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近测试了以下 &lt;code&gt;chroot&lt;/code&gt;，然后把步骤写成了下面两个脚本，方便以后使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Arch&lt;/code&gt; 分区结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/dev/sda5&#x9;/&#xA;/dev/sda1&#x9;/boot&#xA;/dev/sda6&#x9;/home&#xA;/dev/sda8&#x9;Swap&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt; 挂载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;_ROOT=/dev/sda5&#xA;_BOOT=/dev/sda1&#xA;#_HOME=/dev/sda6&#xA;&#xA;#创建目录结构&#xA;sudo mkdir -p /mnt/arch&#xA;sudo mkdir -p /mnt/arch/boot&#xA;#sudo mkdir -p /mnt/arch/home&#xA;&#xA;#挂载分区&#xA;sudo mount $_ROOT /mnt/arch&#xA;sudo mount $_BOOT /mnt/arch/boot&#xA;#sudo mount $_HOME /mnt/arch/home&#xA;&#xA;#挂载临时文件系统&#xA;cd /mnt/arch&#xA;sudo mount -t proc proc proc/&#xA;sudo mount -t sysfs sys sys/&#xA;sudo mount -o bind /dev dev/&#xA;sudo mount -t devpts pts dev/pts&#xA;&#xA;#如果你已经建立了一个网络连接并且想要在chroot环境中使用它，&#xA;#你可能不得不拷贝你的DNS服务器配置让你能够解析主机名&#xA;sudo  cp -L /etc/resolv.conf etc/resolv.conf&#xA;&#xA;# chroot 并指定 shell&#xA;sudo chroot /mnt/arch /usr/bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt;  卸载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;#在退出 chroot 后执行此脚本&#xA;&#xA;#卸载临时文件系统和已挂载的设备&#xA;#sudo umount {proc,sys,dev/pts,dev,boot,home}&#xA;sudo umount {proc,sys,dev/pts,dev,boot}&#xA;&#xA;#尝试卸载根分区&#xA;cd /&#xA;sudo umount /mnt/arch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在 VPS 中搭建 VPN 服务器</title>
      <link>http://45.62.229.81:8080/Blog/%E5%9C%A8-VPS-%E4%B8%AD%E6%90%AD%E5%BB%BA-VPN-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近 &lt;code&gt;Google&lt;/code&gt; 被封，而用 &lt;code&gt;Goagent&lt;/code&gt; 做代理进行访问的效果而不是很理想，所以就想去买 &lt;code&gt;VPN/VPS&lt;/code&gt;。几经考虑后，就去买了个便宜 &lt;code&gt;VPS&lt;/code&gt;，这样也就可以分享给家人用了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;VPS&lt;/code&gt; 中安装的是 &lt;code&gt;Ubuntu&lt;/code&gt;，所以搭建 &lt;code&gt;VPN&lt;/code&gt; 服务器也就是在 &lt;code&gt;Ubuntu&lt;/code&gt; 上面搭建，具体方法如下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：下面所有的操作都是以 &lt;code&gt;root&lt;/code&gt; 用户进行的，非 &lt;code&gt;root&lt;/code&gt; 用户请在命令前加上 &lt;code&gt;sudo&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;pptp&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;apt-get install pptpd&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置 &lt;code&gt;IP&lt;/code&gt; 地址范围及服务器 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/pptpd.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消下面内容的注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;option /etc/ppp/pptpd-options&#xA;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;添加用于登录的账户&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/chap-secrets&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;格式如下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;用户名    pptpd   &amp;quot;密码&amp;quot;    *&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;密码需要用英文双引号，最后的星号(*)代表允许接入的 &lt;code&gt;IP&lt;/code&gt; 可以是任意 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;设置 &lt;code&gt;DNS&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/pptpd-options&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;找到 &lt;code&gt;ms-dns&lt;/code&gt;，取消掉注释，并修改 &lt;code&gt;DNS&lt;/code&gt; 地址，推荐使用 &lt;code&gt;Google DNS&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; 8.8.8.8 &#xA; 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;打开内核 &lt;code&gt;IP&lt;/code&gt; 转发&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消以下内容的注释：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使其生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysctl -p&#xA;/etc/init.d/procps restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;iptables&lt;/code&gt; 并设置&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;开放主机防火墙 &lt;code&gt;VPN&lt;/code&gt; 端口（默认为 &lt;code&gt;1723&lt;/code&gt;）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables -I INPUT -p tcp --dport 1723 -j ACCEPT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;立刻让内核支持 &lt;code&gt;NAT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了让每次重启都生效，还需要在 &lt;code&gt;/etc/rc.local&lt;/code&gt; 文件添加命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;SSH` 代理&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;如要使用 &lt;code&gt;ssh&lt;/code&gt; 作为代理，则需要创建用户。若此用户只作为 &lt;code&gt;ssh&lt;/code&gt; 代理用，则不要登录 &lt;code&gt;shell&lt;/code&gt; 及主目录，使用以下命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;useradd -s /bin/false  test&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在客户端(&lt;code&gt;linux&lt;/code&gt;)中使用以下命令连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ssh -qTfnN -D 7070 test@xxx.xxx.xxx.xxx&lt;/code&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: md5 sum</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--md5-sum/</link>
      <pubDate>2014-06-22 10:54:38 +0800</pubDate>
      <description>&lt;p&gt;使用 Go 语言实现字符串与文件的 MD5 值计算，但是大文件不要使用此方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;crypto/md5&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;&#x9;MD5_STR_LEN = 32&#xA;)&#xA;&#xA;func md5ByteToStr(bytes [16]byte) string {&#xA;&#x9;str := &amp;quot;&amp;quot;&#xA;&#xA;&#x9;for _, b := range bytes {&#xA;&#x9;&#x9;s := strconv.FormatInt(int64(b), 16)&#xA;&#x9;&#x9;if len(s) == 1 {&#xA;&#x9;&#x9;&#x9;str += &amp;quot;0&amp;quot; + s&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;str += s&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return str&#xA;}&#xA;&#xA;func SumStrMd5(str string) (string, bool) {&#xA;&#x9;if len(str) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum([]byte(str))&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&#xA;func SumFileMd5(filename string) (string, bool) {&#xA;&#x9;if !IsFileExist(filename) {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum(contents)&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 判断文件是否存在</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>2014-06-20 09:38:13 +0800</pubDate>
      <description>&lt;p&gt;使用 GoLang 判断文件是否存在。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func isFileExist(filename string) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;_, err := os.Stat(filename)&#xA;&#xA;&#x9;return err == nil || os.IsExist(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: URI Encode/Decode</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--URI-Encode%2FDecode/</link>
      <pubDate>2014-06-20 09:20:12 +0800</pubDate>
      <description>&lt;p&gt;最近在处理路径时，要求统一用 URI(通用资源标识符) 的格式来表示。偶尔会遇到 URI 被编码的情况，这就需要解码了，故在此把 Encode/Decode URI 的方法记录在此，以备后用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;net/url&amp;quot;&#xA;)&#xA;&#xA;/**&#xA; * Input: filepath&#xA; * Output: encode string&#xA; */&#xA;func encodeURI (filepath string) string {&#xA;&#x9;if len(filepath) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u := url.URL{}&#xA;&#x9;u.Path = filepath&#xA;&#x9;return u.String()&#xA;}&#xA;&#xA;/**&#xA; * Input: URI string&#xA; * Output: filepath&#xA; */&#xA;func decodeURI (uri string) string {&#xA;&#x9;if len(uri) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u, err := url.Parse(uri)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;return u.Path&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>XRecord 示例</title>
      <link>http://45.62.229.81:8080/Note/XRecord-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-04-18 05:42:15 +0800</pubDate>
      <description>&lt;p&gt;最近在做快捷键绑定的项目，但在绑定单按键时发现 &lt;code&gt;XGrabKey&lt;/code&gt; 无法处理。遂请教组长，得知 &lt;code&gt;XRecord&lt;/code&gt; 可以处理，于是就去查找 &lt;code&gt;XRecord&lt;/code&gt; 的相关资料，但却很少。&#xA;所以在此记录一下整理的示例代码，以便日后查看，其功能在代码注释中写出。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*&#xA; * XRecord 是 XLib 的一个扩展，在 xtst 中。&#xA; * 此程序用来监听按键、鼠标点击和鼠标移动事件&#xA; */&#xA;&#xA;#include &amp;lt;glib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlibint.h&amp;gt;&#xA;#include &amp;lt;X11/extensions/record.h&amp;gt;&#xA;&#xA;typedef struct _RecordEventInfo {&#xA;        Display *ctrl_disp; // 控制通道&#xA;        Display *data_disp; // 数据通道&#xA;        XRecordRange *range;&#xA;        XRecordContext context;&#xA;} RecordEventInfo;&#xA;&#xA;typedef union {&#xA;        unsigned char type; // 事件类型&#xA;        xEvent xe; // 事件&#xA;} RecordDate;&#xA;&#xA;static void record_init ();&#xA;static void record_finalize ();&#xA;static void record_event_cb (XPointer user_data, XRecordInterceptData *hook);&#xA;static gpointer enable_ctx_thread (gpointer user_data);&#xA;&#xA;GMainLoop *loop= NULL;&#xA;static RecordEventInfo *grab_info = NULL;&#xA;&#xA;static void&#xA;record_init ()&#xA;{&#xA;        grab_info = g_new0 (RecordEventInfo, 1);&#xA;&#xA;        if ( !grab_info ) {&#xA;                g_warning (&amp;quot;Alloc RecordEventInfo memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;ctrl_disp = XOpenDisplay (NULL);&#xA;        grab_info-&amp;gt;data_disp = XOpenDisplay (NULL);&#xA;&#xA;        if ( !grab_info-&amp;gt;ctrl_disp || !grab_info-&amp;gt;data_disp ) {&#xA;                g_warning (&amp;quot;Unable to connect to X server...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        gint dummy;&#xA;&#xA;        if ( !XQueryExtension (grab_info-&amp;gt;ctrl_disp, &amp;quot;XTEST&amp;quot;,&#xA;                                   &amp;amp;dummy, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;XTest extension missing...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        if ( !XRecordQueryVersion (grab_info-&amp;gt;ctrl_disp, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;Failed to obtain xrecord version...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;range = XRecordAllocRange ();&#xA;&#xA;        if ( !grab_info-&amp;gt;range ) {&#xA;                g_warning (&amp;quot;Alloc XRecordRange memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        // 定义需要监听的事件范围，具体见 XRecord 文档&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.first = KeyPress;&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.last = MotionNotify;&#xA;&#xA;        XRecordClientSpec spec = XRecordAllClients;&#xA;        grab_info-&amp;gt;context = XRecordCreateContext (&#xA;                                                grab_info-&amp;gt;data_disp,&#xA;                                                0, &amp;amp;spec, 1,&#xA;                                                &amp;amp;grab_info-&amp;gt;range, 1);&#xA;&#xA;        if ( !grab_info-&amp;gt;context ) {&#xA;                g_warning (&amp;quot;Unable to create context...&amp;quot;);&#xA;                record_finalize();&#xA;        }&#xA;&#xA;        XSynchronize (grab_info-&amp;gt;ctrl_disp, TRUE);&#xA;        XFlush (grab_info-&amp;gt;ctrl_disp);&#xA;&#xA;        // 创建线程来处理接收到的数据&#xA;        GThread *thrd = g_thread_new (&amp;quot;enable context&amp;quot;,&#xA;                                (GThreadFunc)enable_ctx_thread, NULL);&#xA;&#xA;        if ( !thrd ) {&#xA;                g_warning (&amp;quot;Unable to create thread...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;}&#xA;&#xA;/*&#xA; * 释放资源&#xA; */&#xA;&#xA;static void&#xA;record_finalize ()&#xA;{&#xA;        if (!grab_info) {&#xA;                return;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;context) {&#xA;                XRecordDisableContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;                XRecordFreeContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;range) {&#xA;                XFree(grab_info-&amp;gt;range);&#xA;                grab_info-&amp;gt;range = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;ctrl_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;ctrl_disp);&#xA;                grab_info-&amp;gt;ctrl_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;data_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;data_disp);&#xA;                grab_info-&amp;gt;data_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info) {&#xA;                g_free (grab_info);&#xA;                grab_info = NULL;&#xA;        }&#xA;}&#xA;&#xA;static gpointer&#xA;enable_ctx_thread (gpointer user_data)&#xA;{&#xA;        // 开始接收数据&#xA;        if ( !XRecordEnableContext (grab_info-&amp;gt;data_disp,&#xA;                                        grab_info-&amp;gt;context,&#xA;                                        record_event_cb, NULL) ) {&#xA;                g_warning (&amp;quot;Unable to enable context...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        g_thread_exit (NULL);&#xA;        g_main_loop_quit(loop);&#xA;&#xA;        return NULL;&#xA;}&#xA;&#xA;static void&#xA;record_event_cb (XPointer user_data, XRecordInterceptData *hook)&#xA;{&#xA;        if ( hook-&amp;gt;category != XRecordFromServer ) {&#xA;                XRecordFreeData(hook);&#xA;                g_warning (&amp;quot;Data not from X server...&amp;quot;);&#xA;                return;&#xA;        }&#xA;&#xA;        RecordDate *data = (RecordDate *)hook-&amp;gt;data;&#xA;        int detail = data-&amp;gt;xe.u.u.detail; // 按键或鼠标的 keycode&#xA;        int event_type = data-&amp;gt;type; // 事件类型&#xA;        // 事件发生时的坐标&#xA;        int rootX = data-&amp;gt;xe.u.keyButtonPointer.rootX;&#xA;        int rootY = data-&amp;gt;xe.u.keyButtonPointer.rootY;&#xA;        /*int time = hook-&amp;gt;server_time;*/&#xA;&#xA;        switch (event_type) {&#xA;        case KeyPress:&#xA;                g_print(&amp;quot;%d pressed\n&amp;quot;, detail);&#xA;                /*KeySym sym = XKeycodeToKeysym(grab_info-&amp;gt;data_disp, detail, 0);*/&#xA;                break;&#xA;&#xA;        case KeyRelease:&#xA;                g_print(&amp;quot;%d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case MotionNotify:&#xA;                g_print(&amp;quot;Mouse Motion: %d -- %d\n&amp;quot;, rootX, rootY);&#xA;                break;&#xA;&#xA;        case ButtonPress:&#xA;                g_print(&amp;quot;Mouse %d pressed\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case ButtonRelease:&#xA;                g_print(&amp;quot;Mouse %d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        default:&#xA;                break;&#xA;        }&#xA;&#xA;        XRecordFreeData(hook);&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        record_init();&#xA;&#xA;        loop = g_main_loop_new(NULL, FALSE);&#xA;        g_main_loop_run(loop);&#xA;        g_main_loop_unref(loop);&#xA;        record_finalize();&#xA;&#xA;        return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>