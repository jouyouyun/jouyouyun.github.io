<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Jouyouyun&#39;s Blog</title>
    <link>http://jouyouyun.github.io</link>
    <pubDate>17 May 17 13:36 CST</pubDate>
    <item>
      <title>Miraclecast 代码整理</title>
      <link>http://jouyouyun.github.io/Note/Miraclecast-%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/</link>
      <pubDate>2017-05-16 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;命令介绍&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miracle-wifid&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;管理 link 及 peer, 控制 wpa_supplicant, 在 group 建立后启用 DHCP&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miracle-wifictl&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;建立 P2P Group , 可直接在命令行使用, 类似 bluetoothctl&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miracle-sinkctl&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;包含 wifictl 的功能, 加上 wifi-display sink 的功能. 会启用 gstplayer, uibc(需要添加命令行参数来启用) 来接受 source 画面并发送 sink 的输入&lt;/p&gt;&#xA;&#xA;&lt;p&gt;连接之后主动向 source 发送 sink 信息, 如: 分辨率, profile, level.&#xA;其中 profile 决定了 encode/decode 的技巧, level 决定了色彩, 2者共同决定了传输的质量及画面的清晰度&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miracle-dispd&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;实现了 wifi-display source 的功能, 管理 session, 启动 gstencoder 发送画面&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;代码结构&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wifi&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;下达命令给 wpa_supplicant, 管理 link 及开启 P2P 模式. 必须先 unmanage nm device&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;管理 link 状态&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;管理 DHCP client/server&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;提供 dbus 操作&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ctl&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;操作 sink/link/peer, 用到 miracle-sinkctl 和 miracle-wifictl&lt;/p&gt;&#xA;&#xA;&lt;p&gt;操作 group 建立后虚拟出的网卡, 可以测速, 检查丢包率等&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;uibc&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;反馈 sink 输入给 source , 在 source 端解析执行 sink 的输入&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;shared&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;rtsp 协议的解析, 与通用的不同&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dispd&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;管理 session&lt;/p&gt;&#xA;&#xA;&lt;p&gt;连接 server bus&lt;/p&gt;&#xA;&#xA;&lt;p&gt;encode 数据, gstencoder 的 wrapper, gst encode/decode 在 res 目录中&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;连接流程&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;获取网卡的管理权, 先取消掉其它程序对网卡的管理权&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置 SubElements 包含了扮演的角色(sink or source or dual), 监听的 port 等数据&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;开始 scan 功能, 并向周围设备广播自己的信息, 根据 Group Owner 优先级开始建组, 值越大优先级越高, 如果相同则由程序自行调整.&#xA;建组失败发送 GoNegFailure 事件, 成功后由 Owner 向组内成员分配 IP, 分配失败发送 FormationFailure 事件&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;开始连接&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;source 向 sink 发送版本信息, sink 发回确认信息&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;source 询问 video-formats, audio-formats 等信息, sink 回应&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;source 向 sink 设置适合的参数, sink 回应&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;接下来就是执行 SETUP, PLAY, PAUSE, TEARDOWN 等命令, 都是由 source 先向 sink 发起执行命令的请求, sink 才向 source 发起需要执行的命令&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;存在的问题&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;声音传输还未测试&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;连接意外崩溃后 gstreamer 未终止&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;程序意外崩溃后界面未做处理&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Debug&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若一直连接失败, 可能是建组失败, IP 分配失败, 防火墙屏蔽了输入输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN Install</title>
      <link>http://jouyouyun.github.io/Blog/OpenVPN-Install/</link>
      <pubDate>2016-12-27 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;安装所需软件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Arch: &lt;code&gt;yaourt -S openvpn easy-rsa&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;生成证书&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Server 端&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Copy template file&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo mkdir -p /etc/openvpn&#xA;sudo cp -R /etc/easy-rsa /etc/openvpn&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Config vars&#xA;取消并修改以下项:&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;set_var EASYRSA_REQ_COUNTRY     &amp;quot;CN&amp;quot;&#xA;set_var EASYRSA_REQ_PROVINCE    &amp;quot;Hongkong&amp;quot;&#xA;set_var EASYRSA_REQ_CITY        &amp;quot;Hongkong&amp;quot;&#xA;set_var EASYRSA_REQ_ORG         &amp;quot;jouyouyun.info&amp;quot;&#xA;set_var EASYRSA_REQ_EMAIL       &amp;quot;wen@jouyouyun.iofn&amp;quot;&#xA;set_var EASYRSA_REQ_OU          &amp;quot;Jouyouyun OpenVPN&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;创建根证书&#xA;&lt;code&gt;ca&lt;/code&gt; 证书需要输入密码，这个密码是给服务器端和客户端签名时用的&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa init-pki&#xA;easyrsa build-ca&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建并签名服务器端证书&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-req &amp;lt;server name&amp;gt; nopass&#xA;easyrsa sign server &amp;lt;server name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建Diffie-Hellman证书&#xA;该证书主要作用是确保共享KEY安全穿越不安全网络&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建并签名客户端证书&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easyrsa gen-req &amp;lt;client name&amp;gt; nopass&#xA;easyrsa sign client &amp;lt;client name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;配置服务器端&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;复制一份模板文件(&lt;code&gt;/usr/share/openvpn/examples/server.conf&lt;/code&gt;)到 &lt;code&gt;/etc/openvpn&lt;/code&gt; 目录, 然后开始修改相关项.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后将证书文件放在 &lt;code&gt;/etc/openvpn&lt;/code&gt; 目录下, 需要的文件包括:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easy-rsa/pki/ca.crt&#xA;easy-rsa/pki/dh.pem&#xA;easy-rsa/pki/issued/&amp;lt;server name&amp;gt;.crt&#xA;easy-rsa/pki/private/&amp;lt;server name&amp;gt;.key&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;配置客户端&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;复制一份模板文件 &lt;code&gt;/usr/share/openvpn/examples/client.conf&lt;/code&gt;, 然后开始修改相关项.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将以下证书文件与配置文件放在一起, 需要的文件包括:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;easy-rsa/pki/ca.crt&#xA;easy-rsa/pki/issued/&amp;lt;client name&amp;gt;.crt&#xA;easy-rsa/pki/private/&amp;lt;client name&amp;gt;.key&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;开启路由转发&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sed -i &#39;/net.ipv4.ip_forward/s/0/1/&#39; /etc/sysctl.conf&#xA;sysctl -p&#xA;# 允许vpn客户端所在网段流量转发到其它网卡&#xA;iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT&#xA;# 将vpn客户端的流量转到eth0，允许vpn客户端上网，即NAT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j  MASQUERADE&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;示例&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;认证可以通过证书认证也可以使用用户名密码认证，推荐使用用户名密码认证, 这样方便添加用户.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;证书认证&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;port 1194&#xA;proto tcp&#xA;dev tun&#xA;&#xA;ca /etc/openvpn/ca.crt&#xA;cert /etc/openvpn/server.crt&#xA;key /etc/openvpn/server.key&#xA;dh /etc/openvpn/dh.pem&#xA;&#xA;server 10.8.0.0 255.255.255.0&#xA;ifconfig-pool-persist /etc/openvpn/ipp.txt&#xA;push &amp;quot;redirect-gateway def1 bypass-dhcp&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;&#xA;client-to-client&#xA;keepalive 10 120&#xA;cipher AES-256-CBC&#xA;;comp-lzo # 禁用压缩，如果开启客户端配置中也需要开启&#xA;max-clients 100&#xA;persist-key&#xA;persist-tun&#xA;&#xA;status /var/log/openvpn/openvpn-status.log&#xA;log         /var/log/openvpn/openvpn.log&#xA;log-append  /var/log/openvpn/openvpn.log&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;client&#xA;dev tun&#xA;proto tcp&#xA;&#xA;resolv-retry infinite&#xA;remote &amp;lt;your vps ip&amp;gt; 1194&#xA;nobind&#xA;&#xA;persist-key&#xA;persist-tun&#xA;&#xA;ca ca.crt&#xA;cert client.crt&#xA;key client.key&#xA;&#xA;cipher AES-256-CBC&#xA;#comp-lzo&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;用户名密码认证&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;需要加入auth-user-pass-verify，开启用户密码脚本, 脚本示例, 读取 &lt;code&gt;/etc/openvpn/passwd&lt;/code&gt; 文件:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh&#xA;###########################################################&#xA;# checkpsw.sh (C) 2004 Mathias Sundman &amp;lt;mathias@openvpn.se&amp;gt;&#xA;#&#xA;# This script will authenticate OpenVPN users against&#xA;# a plain text file. The passfile should simply contain&#xA;# one row per user with the username first followed by&#xA;# one or more space(s) or tab(s) and then the password.&#xA;&#xA;PASSFILE=&amp;quot;/etc/openvpn/passwd&amp;quot;&#xA;LOG_FILE=&amp;quot;/var/log/openvpn/openvpn-password.log&amp;quot;&#xA;TIME_STAMP=`date &amp;quot;+%Y-%m-%d %T&amp;quot;`&#xA;&#xA;###########################################################&#xA;&#xA;if [ ! -r &amp;quot;${PASSFILE}&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: Could not open password file \&amp;quot;${PASSFILE}\&amp;quot; for reading.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 1&#xA;fi&#xA;&#xA;CORRECT_PASSWORD=`awk &#39;!/^;/&amp;amp;&amp;amp;!/^#/&amp;amp;&amp;amp;$1==&amp;quot;&#39;${username}&#39;&amp;quot;{print $2;exit}&#39; ${PASSFILE}`&#xA;&#xA;if [ &amp;quot;${CORRECT_PASSWORD}&amp;quot; = &amp;quot;&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: User does not exist: username=\&amp;quot;${username}\&amp;quot;, password=\&amp;quot;${password}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 1&#xA;fi&#xA;&#xA;if [ &amp;quot;${password}&amp;quot; = &amp;quot;${CORRECT_PASSWORD}&amp;quot; ]; then&#xA;  echo &amp;quot;${TIME_STAMP}: Successful authentication: username=\&amp;quot;${username}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;  exit 0&#xA;fi&#xA;&#xA;echo &amp;quot;${TIME_STAMP}: Incorrect password: username=\&amp;quot;${username}\&amp;quot;, password=\&amp;quot;${password}\&amp;quot;.&amp;quot; &amp;gt;&amp;gt; ${LOG_FILE}&#xA;exit 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;port 1194&#xA;proto tcp&#xA;dev tap&#xA;&#xA;#不要求客户端有证书&#xA;client-cert-not-required&#xA;username-as-common-name&#xA;&#xA;script-security 3 system&#xA;#使用脚本验证密码&#xA;auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env&#xA;&#xA;ca   /etc/openvpn/keys/ca.crt&#xA;cert /etc/openvpn/keys/server.crt&#xA;key  /etc/openvpn/keys/server.key&#xA;dh   /etc/openvpn/keys/dh1024.pem&#xA;&#xA;server 10.8.6.0 255.255.255.0&#xA;&#xA;#保存已有的用户和ip的对应关系&#xA;ifconfig-pool-persist ipp.txt&#xA;&#xA;#允许客户端之间互访&#xA;client-to-client&#xA;&#xA;keepalive 10 120&#xA;&#xA;user nobody&#xA;group nogroup&#xA;&#xA;persist-key&#xA;persist-tun&#xA;&#xA;#保存日志&#xA;status openvpn-status.log&#xA;#日志冗余级别&#xA;verb 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;客户端配置文件中去掉于证书相关的配置，加入 &lt;code&gt;auth-user-pass&lt;/code&gt; 打开用户名密码验证.&#xA;可以加入auth-nocache可以在断线后防止内存中保存用户名和密码来提高安全性。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-24250828-id-3536671.html&#34;&gt; Linux 下OpenVPN 密钥认证 和 用户名/密码认证 笔记&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>MIME Usage</title>
      <link>http://jouyouyun.github.io/Blog/MIME-Usage/</link>
      <pubDate>2016-12-14 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;基本使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用到的工具为: xdg-mime, gvfs-mime&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询文件的类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;xdg-mime query filetype &amp;lt;filepath&amp;gt;&lt;/code&gt; 可以得到文件的类型&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询默认程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;xdg-mime query default text/plain&lt;/code&gt; 或 &lt;code&gt;gvfs-mime --query &amp;lt;mimetype&amp;gt;&lt;/code&gt;, &lt;code&gt;gvfs-mime&lt;/code&gt; 还会列出支持此 &lt;code&gt;mimetype&lt;/code&gt; 的所有程序&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置默认程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如将 &lt;code&gt;text/plain&lt;/code&gt; 的默认打开程序设置为 &lt;code&gt;gvim.desktop&lt;/code&gt;, 可以执行 &lt;code&gt;xdg-mime default gvim.desktop text/plain&lt;/code&gt; 或 &lt;code&gt;gvfs-mime --set text/plain gvim.desktop&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;根据文件扩展名指定类型&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;创建 &lt;code&gt;xml&lt;/code&gt; 文件, 指定类型, 如将 &lt;code&gt;*.org&lt;/code&gt; 指定为 &lt;code&gt;text/org-mode&lt;/code&gt;, 文件内容如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;&amp;lt;mime-info xmlns=&amp;quot;http://www.freedesktop.org/standards/shared-mime-info&amp;quot;&amp;gt;&#xA;  &amp;lt;mime-type type=&amp;quot;text/org-mode&amp;quot;&amp;gt;&#xA;         &amp;lt;comment xml:lang=&amp;quot;en&amp;quot;&amp;gt;Org-Mode File&amp;lt;/comment&amp;gt;&#xA;         &amp;lt;glob pattern=&amp;quot;*.org&amp;quot;/&amp;gt;&#xA;  &amp;lt;/mime-type&amp;gt;&#xA;&amp;lt;/mime-info&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;将上面的 &lt;code&gt;xml&lt;/code&gt; 文件复制到 &lt;code&gt;$XDG_DATA_DIRS/mime/packages&lt;/code&gt; 中, 即文件要在 &lt;code&gt;~/.local/share/mime/packages, /usr/local/share/mime/packages, /usr/share/mime/packages&lt;/code&gt; 这几个目录中的一个&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;update-mime-database &amp;lt;MIME DIR&amp;gt;&lt;/code&gt; 更新 &lt;code&gt;mime datebase&lt;/code&gt;, 上面的目录去掉 &lt;code&gt;packages&lt;/code&gt; 就是 &lt;code&gt;MIME DIR&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;这样 &lt;code&gt;*.org&lt;/code&gt; 的类型就变为 &lt;code&gt;text/org-mode&lt;/code&gt; 了, 参考 &lt;a href=&#34;https://freedesktop.org/wiki/Specifications/AddingMIMETutor/&#34;&gt;Add MIME Type&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>DDE Package List</title>
      <link>http://jouyouyun.github.io/Note/DDE-Package-List/</link>
      <pubDate>2016-08-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;现决定龙芯与专业版使用同一分支进行打包, 两者要保持版本一致, 对于需要特殊设置的地方, 请已 &lt;code&gt;patch&lt;/code&gt; 的方式存放到单独的仓库, 打包时去自动拉取.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;专业版桌面打包列表及分支(包名与仓库名系统的用 &lt;code&gt;-&lt;/code&gt; 表示, 仓库名没有的用 &lt;code&gt;?&lt;/code&gt; 表示):&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Package Name&lt;/th&gt;&#xA;&lt;th&gt;Repo Name&lt;/th&gt;&#xA;&lt;th&gt;Branch&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dbus-factory&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-control-center&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-daemon&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-desktop&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-dock&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-launcher&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-session-ui&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-desktop-schemas&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-desktop-base&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;raccoon&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-mutter&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-file-manager-backend&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;golang-dlib-dev&lt;/td&gt;&#xA;&lt;td&gt;go-lib&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;go-gir-genrator&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-install&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-appstore&lt;/td&gt;&#xA;&lt;td&gt;dstore/deepin-appstore&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-default-settings&lt;/td&gt;&#xA;&lt;td&gt;default-settings&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-icon-theme&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-remote-assistance&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-tool-kit&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;deepin-license&lt;/td&gt;&#xA;&lt;td&gt;-&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde-help&lt;/td&gt;&#xA;&lt;td&gt;dde/dde-help&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;dde&lt;/td&gt;&#xA;&lt;td&gt;?&lt;/td&gt;&#xA;&lt;td&gt;master&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;</description>
    </item>
    <item>
      <title>xrandr examples</title>
      <link>http://jouyouyun.github.io/Blog/xrandr-examples/</link>
      <pubDate>2016-06-06 04:52:30 +0800</pubDate>
      <description>&lt;p&gt;由于经常会用到使用 &lt;code&gt;xrandr&lt;/code&gt; 设置屏幕属性, 而每次用的时候都要去查 &lt;code&gt;man&lt;/code&gt; 手册, 有时还需要上网搜索例子.&#xA;这样一来就比较麻烦, 所以就想整理下 &lt;code&gt;xrandr&lt;/code&gt; 的用法, 给出一些常用的例子.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;查询&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;xrandr -q&lt;/code&gt; 命令可以查询当前的显示器状态, 使用 &lt;code&gt;xrandr --verbose&lt;/code&gt; 将会显示更详细的信息.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置分辨率时需要指定设置的 &lt;code&gt;ouput&lt;/code&gt; 以及 &lt;code&gt;mode&lt;/code&gt;, 如将 &lt;code&gt;eDP1&lt;/code&gt; 的分辨率改为 &lt;code&gt;1920x1080&lt;/code&gt;, 命令就是 &lt;code&gt;xrandr --output eDP1 --mode 1920x1080&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是单屏时不用这么麻烦, 可以直接使用命令 &lt;code&gt;xrandr -s 1920x1080&lt;/code&gt; 来更改.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;添加分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果 &lt;code&gt;xrandr -q&lt;/code&gt; 查询的结果中没有合适的分辨率, 则可以通过 &lt;code&gt;newmode&lt;/code&gt; 来添加一个, 下面将给出为 &lt;code&gt;eDP1&lt;/code&gt; 添加 &lt;code&gt;1440x900x60&lt;/code&gt; 的分辨率的方法.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;cvt&lt;/code&gt; 生成一个 &lt;code&gt;modeline&lt;/code&gt;, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;cvt 1440 900 60&#xA;# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz&#xA;Modeline &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;newmode&lt;/code&gt; 创建一个 &lt;code&gt;mode&lt;/code&gt;, 参数就是上面 &lt;code&gt;Modeline&lt;/code&gt; 后的内容, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;xrandr --newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;将上面的 &lt;code&gt;mode&lt;/code&gt; 添加到 &lt;code&gt;eDP1&lt;/code&gt; 中:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;xrandr --addmode eDP1 1440x900_60.00&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果执行出错, 则说明不支持此模式. 如果没有错误则添加完成, 然后就可以设置此 &lt;code&gt;mode&lt;/code&gt; 为分辨率了.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;双屏配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如现在有两个 &lt;code&gt;output&lt;/code&gt;, 分别是 &lt;code&gt;eDP1&lt;/code&gt; 和 &lt;code&gt;VGA1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;设置主屏&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;通过指定 &lt;code&gt;--primary&lt;/code&gt; 参数来设置主屏, 如设置 &lt;code&gt;eDP1&lt;/code&gt; 为主屏: &lt;code&gt;xrandr --auto --output eDP1 --primary&lt;/code&gt;, &lt;code&gt;--auto&lt;/code&gt; 可以自动启用关闭的屏幕.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;复制模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;复制模式最好使用两个显示器都有的 &lt;code&gt;mode&lt;/code&gt; 作为默认的 &lt;code&gt;mode&lt;/code&gt;, 命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1440x900 --output VGA1 --same-as eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;扩展模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --mode 1440x900 --right-of eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;命令的结果就是 &lt;code&gt;VGA1&lt;/code&gt; 会在 &lt;code&gt;eDP1&lt;/code&gt; 的右边, &lt;code&gt;eDP1&lt;/code&gt; 为主屏, 另外位置的参数还有 &lt;code&gt;left-of&lt;/code&gt;, &lt;code&gt;--above&lt;/code&gt;, &lt;code&gt;--below&lt;/code&gt; 等.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果需要自定义两个屏幕的位置, 可以通过计算每个屏幕的分辨率, 用 &lt;code&gt;--pos&lt;/code&gt; 参数来指定每个屏幕显示的位置.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;单屏模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这个模式是只显示某一个屏幕, 如只显示 &lt;code&gt;eDP1&lt;/code&gt;, 可以使用命令 &lt;code&gt;xrandr --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --off&lt;/code&gt;,&#xA;这样就会把 &lt;code&gt;VGA1&lt;/code&gt; 给关闭.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;其它&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;另外屏幕的旋转, 镜像和缩放可以分别使用 &lt;code&gt;--rotate&lt;/code&gt;, &lt;code&gt;reflect&lt;/code&gt; 和 &lt;code&gt;--scale&lt;/code&gt; 参数来实现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至于更详细的信息请使用 &lt;code&gt;man xrandr&lt;/code&gt; 来查看.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Enable coredump</title>
      <link>http://jouyouyun.github.io/Note/Enable-coredump/</link>
      <pubDate>2016-04-25 07:04:33 +0800</pubDate>
      <description>&lt;h2&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当一个程序崩溃时会产生一个 &lt;code&gt;core&lt;/code&gt; 文件, 里面记录了这个程序崩溃的原因, 这些信息对于开发者是很有用的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是 &lt;code&gt;core dumps&lt;/code&gt; 在大多数 &lt;code&gt;linux&lt;/code&gt; 上是被禁用的, 下面就介绍下如何开启这个功能.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;开启&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;ulimit -c&lt;/code&gt; 的输出知道此功能是否开启, 输出为 &lt;code&gt;0&lt;/code&gt; 表示禁用, 否则为开启.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;临时开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通过 &lt;code&gt;ulimit -c unlimited&lt;/code&gt; 命令来开启 &lt;code&gt;coredump&lt;/code&gt; 功能, 它会程序运行的当前目录生成一个 &lt;code&gt;core&lt;/code&gt; 文件, 新的 &lt;code&gt;core&lt;/code&gt; 会覆盖旧的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过可以修改 &lt;code&gt;/proc/sys/kernel/core_uses_pid&lt;/code&gt; 文件内容为 &lt;code&gt;1&lt;/code&gt; 来生成以 &lt;code&gt;pid&lt;/code&gt; 作为扩展名的 &lt;code&gt;core&lt;/code&gt; 文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过修改 &lt;code&gt;/proc/sys/kernel/core_pattern&lt;/code&gt; 可以修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式. 如把内容改为 &lt;code&gt;/tmp/core-%e-%p-%t&lt;/code&gt;, 就表示把 &lt;code&gt;core&lt;/code&gt; 文件保存到 &lt;code&gt;/tmp&lt;/code&gt; 目录下, 文件名的格式为 &lt;code&gt;core-命令名-pid-时间戳&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;永久开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;首先把开启 &lt;code&gt;coredump&lt;/code&gt; 功能的命令 &lt;code&gt;ulimit -c unlimited &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 放到 &lt;code&gt;/etc/profile&lt;/code&gt; 中.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式, 在 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件中添加一下内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kernel.core_uses_pid = 1&#xA;kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改完 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 后, 执行 &lt;code&gt;sudo sysctl -p&lt;/code&gt; 重新加载配置.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;core pattern&lt;/code&gt; 说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;%% – A single % character&#xA;%p – PID of dumped process&#xA;%u – real UID of dumped process&#xA;%g – real GID of dumped process&#xA;%s – number of signal causing dump&#xA;%t – time of dump (seconds since 0:00h, 1 Jan 1970)&#xA;%h – hostname (same as ’nodename’ returned by uname(2))&#xA;%e – executable filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.linuxreviews.org/HOWTO_enable_core-dumps&#34;&gt;HOWTO enable core-dumps&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cyberciti.biz/tips/linux-core-dumps.html&#34;&gt;HowTo: Debug Crashed Linux Application Core Files&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Auto Hidden Cursor</title>
      <link>http://jouyouyun.github.io/Blog/Auto-Hidden-Cursor/</link>
      <pubDate>2016-04-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近需要做一个隐藏光标的功能, 在这里将了解到的知识总结一下.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标的原理就是把光标设置为一个 &lt;code&gt;x11 null cursor&lt;/code&gt;, 不需要隐藏时再将它设为 &lt;code&gt;x11 left_ptr cursor&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置光标主要需要调用下面两个函数:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int XDefineCursor(Display *display, Window w, Cursor cursor);&#xA;void XFixesChangeCursorByName (Display *dpy, Cursor source, const char *name);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;创建光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;至于创建 &lt;code&gt;null cursor&lt;/code&gt; 可以见下面的代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;window = DefaultRootWindow(display);&#xA;Cursor invisibleCursor;&#xA;Pixmap bitmapNoData;&#xA;XColor black;&#xA;static char noData[] = { 0,0,0,0,0,0,0,0 };&#xA;black.red = black.green = black.blue = 0;&#xA;bitmapNoData = XCreateBitmapFromData(display, window, noData, 8, 8);&#xA;invisibleCursor = XCreatePixmapCursor(display, bitmapNoData, bitmapNoData, &amp;amp;black, &amp;amp;black, 0, 0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;创建完后, 将其设置为默认光标就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外 &lt;code&gt;libxfixes&lt;/code&gt; 也提供了隐藏/显示光标的接口:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void XFixesHideCursor (Display *dpy, Window win);&#xA;void XFixesShowCursor (Display *dpy, Window win);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;其它&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标推荐使用 &lt;code&gt;unclutter&lt;/code&gt; 来设置, 它可以自定义空闲时间, 具体功能请见 &lt;code&gt;man&lt;/code&gt; 手册.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果使用 &lt;code&gt;lightdm&lt;/code&gt; 作为登录管理器, 可以编辑 &lt;code&gt;/etc/lightdm/lightdm.conf&lt;/code&gt; 文件,&#xA;在 &lt;code&gt;[Seat:*]&lt;/code&gt; 后添加 &lt;code&gt;xserver-command=X -bs -core -nocursor&lt;/code&gt;.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>debug 小结</title>
      <link>http://jouyouyun.github.io/Note/debug-%E5%B0%8F%E7%BB%93/</link>
      <pubDate>2016-02-03 03:06:35 +0800</pubDate>
      <description>&lt;p&gt;调试 &lt;code&gt;bug&lt;/code&gt; 的时候要有耐心, 要不断测试, 直到找到问题原因.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;确定 &lt;code&gt;bug&lt;/code&gt; 出现的方式&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一定要找到稳定重现的方式, 这样才能方便下面的调试&lt;/li&gt;&#xA;&lt;li&gt;如果找不到稳定重现的方法就只能根据上次出现的情形, 去查看相关的代码, 猜测可能出问题的地方, 然后针对那一块进行调试, 直到找到稳定重现方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;定位出问题的代码&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再找到稳定重现方式后, 开始定位出问题的函数, 然后加入调试信息, 不断尝试, 直到找到有问题的代码&lt;/li&gt;&#xA;&lt;li&gt;找到有问题的代码后, 如果发现是第三方库里的函数,可以打印出每次调用的输入输出参数, 看看是否有迹可循, 可以单独写个小程序, 传入问题的参数, 进行不断测试, 来确定第三方库有没有问题&lt;/li&gt;&#xA;&lt;li&gt;如果自己程序的代码, 就一行一行的慢慢测试, 确定问题的原因, 原因找到了就可以开始思考解决方法了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;修复 &lt;code&gt;bug&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;修复 &lt;code&gt;bug&lt;/code&gt; 时一定要仔细检查新添加的代码, 看看会不会造成其它的 &lt;code&gt;bug&lt;/code&gt;, 一定要不断测试, 把函数输入输出状态都打印出来, 以免出现界面是对的, 但函数的数据有误.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于开源的第三方库有问题时, 就把它的代码下下来, 加上调试信息后, 然后安装, 让你的程序使用自己编译的第三方库, 这样方便查找问题.&#xA;因为有时可能第三方库再使用时需要初始化一些资源, 而你使用的接口并没有做或少做了一点, 这样就导致你的程序出了问题.&#xA;这时就可以在程序中添加相关的初始化代码, 来处理这类问题, 这类问题一般第三方库升级时可能出现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若知道问题的原因后(这个原因一定要是相关低层的, 不能说是由于 A 调了 B , B 出问题了, 就把问题原因归与 A 的头上, 一定要是相当精确的), 不知道怎么修改, 这时就可以向组内成员求助, 或者去了解这方面的知识.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;性能调试工具&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于 &lt;code&gt;C/C++&lt;/code&gt; 代码, 可以使用 &lt;code&gt;Google Proftools&lt;/code&gt; 工具来调试. 它以程序调用的方式生成每次调用的性能消耗图, 方便定位占用资源多的函数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文档见: &lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/&#34;&gt;Google Proftools Documents&lt;/a&gt; , 使用方法自行 &lt;code&gt;google&lt;/code&gt; .&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;网站推荐&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;还可以去一些开发者网站提问:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.quora.com/&#34;&gt;国外的知乎: Quora&lt;/a&gt;&#xA;&lt;a href=&#34;http://segmentfault.com/&#34;&gt;SegmentFault&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者到 &lt;a href=&#34;http://www.ibm.com/developerworks/cn/&#34;&gt;IBM Developer&lt;/a&gt; 看写相关的技术文章, 前端的话还可以去 &lt;a href=&#34;https://developer.mozilla.org/&#34;&gt;Mozilla Developer&lt;/a&gt; .&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>xsetwacom 选项说明</title>
      <link>http://jouyouyun.github.io/Blog/xsetwacom-%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/</link>
      <pubDate>2016-02-03 02:58:29 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;xsetwacom&lt;/code&gt; 是一个设置数位板的命令行工具, 在 &lt;code&gt;Debian/Ubuntu/deepin&lt;/code&gt; 上可以通过安装 &lt;code&gt;xserver-xorg-input-wacom&lt;/code&gt; 来获取它.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;man xsetwacom&lt;/code&gt; 看到它的帮助文档, 下面就简单说明下它的部份选项:&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Options&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Area&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 x2 y2,&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板可使用的区域&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Button&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: button-number [mapping]&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔按钮的功能，可自定义为组合键，详细使用方法见文档&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;MapToOutput&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: output&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板与显示屏的映射，可以使用 &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;Head Number&lt;/code&gt;, &lt;code&gt;X11 geometry&lt;/code&gt; 三种方式设置&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;output: 如 &lt;code&gt;VGA1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Head Number: 通过 &lt;code&gt;XRandR extension&lt;/code&gt; 得到的&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;X11 geometry: 格式如 &lt;code&gt;WIDTHxHEIGHT+X+Y&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Mode&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: Absolute|Relative&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: Absolute&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置笔模式。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Absolute: 模式时数位笔对应的是数位板或屏幕的真实位置&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Relative: 模式时数位笔就像是一个鼠标&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;PressureCurve&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 100 100&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 压力曲线，(x1&lt;y1 x2&lt;y2) to &#34;soften&#34;，(x1&gt;y1 x2&amp;gt;y2) to &amp;ldquo;firmer&amp;rdquo;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;RawSample&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 20)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 4&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔原始采样率对应的窗口大小，不太清楚有什么用&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Rotate&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: none|half|cw|ccw&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: none&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置旋转度&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;none: 不旋转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;half: 上下翻转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;cw: 顺时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;ccw: 逆时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Suppress&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 100)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置移动灵敏度，值越大灵敏度越低&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Touch&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许触摸&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;HWTouchSwitchState&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许调节 &lt;code&gt;Touch&lt;/code&gt; 选项&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Threshold&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 2047)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 27&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置产生按键事件的最小力度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;其他&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于压力曲线，这里给出了一些测试值，从 &lt;code&gt;soften&lt;/code&gt; 到 &lt;code&gt;firmer&lt;/code&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0 100 0 100&lt;/li&gt;&#xA;&lt;li&gt;20 80 20 80&lt;/li&gt;&#xA;&lt;li&gt;30 70 30 70&lt;/li&gt;&#xA;&lt;li&gt;0 0 100 100&lt;/li&gt;&#xA;&lt;li&gt;60 40 60 40&lt;/li&gt;&#xA;&lt;li&gt;70 30 70 30&lt;/li&gt;&#xA;&lt;li&gt;75 25 75 25&lt;/li&gt;&#xA;&lt;li&gt;80 20 80 20&lt;/li&gt;&#xA;&lt;li&gt;90 10 90 10&lt;/li&gt;&#xA;&lt;li&gt;100 0 100 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 简单的 TCP Socket 示例</title>
      <link>http://jouyouyun.github.io/Note/Go-%E7%AC%94%E8%AE%B0--%E7%AE%80%E5%8D%95%E7%9A%84-TCP-Socket-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-07-20 12:54:43 +0800</pubDate>
      <description>&lt;p&gt;一个简单的 &lt;code&gt;TCP Socket&lt;/code&gt; 的示例，使用 &lt;code&gt;gob&lt;/code&gt; 处理传输的数据。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;server.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;const (&#xA;&#x9;BUF_SIZE = 1024&#xA;)&#xA;&#xA;func handleConnection(conn *net.TCPConn) {&#xA;&#x9;if conn == nil {&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;defer conn.Close()&#xA;&#xA;&#x9;data := make([]byte, BUF_SIZE)&#xA;&#x9;for {&#xA;&#x9;&#x9;n, err := conn.Read(data)&#xA;&#x9;&#x9;if err == io.EOF {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Read connection data failed:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Read %v byte data\n&amp;quot;, n)&#xA;&#xA;&#x9;&#x9;b := bytes.NewBuffer(data)&#xA;&#x9;&#x9;dec := gob.NewDecoder(b)&#xA;&#xA;&#x9;&#x9;info := personInfo{}&#xA;&#x9;&#x9;dec.Decode(&amp;amp;info)&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Server receive data: %v\n&amp;quot;, info)&#xA;&#x9;}&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;l, err := net.ListenTCP(&amp;quot;tcp&amp;quot;, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Listen port error:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;conn, err := l.AcceptTCP()&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;The client: %s connected\n&amp;quot;, conn.RemoteAddr().String())&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Accept error:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;go handleConnection(conn)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;client.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;&#x9;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;conn, err := net.DialTCP(&amp;quot;tcp&amp;quot;, nil, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Create connection failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;info := personInfo{&amp;quot;Maya&amp;quot;, 18, &amp;quot;13277085678&amp;quot;, &amp;quot;Hubei China&amp;quot;}&#xA;&#x9;var b bytes.Buffer&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;b)&#xA;&#x9;enc.Encode(&amp;amp;info)&#xA;&#x9;for {&#xA;&#x9;&#x9;conn.Write(b.Bytes())&#xA;&#x9;&#x9;fmt.Println(b.Bytes())&#xA;&#x9;&#x9;&amp;lt;-time.After(time.Second * 3)&#xA;&#x9;}&#xA;&#x9;conn.Close()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记：Gob Write/Read File</title>
      <link>http://jouyouyun.github.io/Note/Go-%E7%AC%94%E8%AE%B0%EF%BC%9AGob-Write%2FRead-File/</link>
      <pubDate>2014-07-07 01:06:28 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;Gob&lt;/code&gt; 使用实例，将结构体写入文件里，在需要的时候再从文件中读取出来。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;type Writer struct {&#xA;&#x9;Id    int&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;type Reader struct {&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;func writeToFile(filename string, data interface{}) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;writeToFile filename invalid&amp;quot;)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;var w bytes.Buffer&#xA;&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;w)&#xA;&#x9;if err := enc.Encode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Encode data error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;if fp, err := os.Create(filename); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Open &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;} else {&#xA;&#x9;&#x9;defer fp.Close()&#xA;&#x9;&#x9;fp.WriteString(w.String())&#xA;&#x9;&#x9;fp.Sync()&#xA;&#x9;}&#xA;&#xA;&#x9;return true&#xA;}&#xA;&#xA;func readFromFile(filename string, data interface{}) {&#xA;&#x9;if len(filename) &amp;lt; 1 || data == nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;readFromFile args invalid&amp;quot;)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;ReadFile &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;r := bytes.NewBuffer(contents)&#xA;&#x9;dec := gob.NewDecoder(r)&#xA;&#xA;&#x9;if err := dec.Decode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Decode error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;wData := Writer{0, &amp;quot;firefox&amp;quot;, &amp;quot;Web Broswer&amp;quot;}&#xA;&#xA;&#x9;writeToFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;wData)&#xA;&#xA;&#x9;rData := Reader{}&#xA;&#x9;readFromFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;rData)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, rData)&#xA;&#xA;&#x9;// test map&#xA;&#x9;w := map[string]string{&#xA;&#x9;&#x9;&amp;quot;sublime-text&amp;quot;: &amp;quot;Sublime Text&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;firefox&amp;quot;:      &amp;quot;Web Broswer&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;terminator&amp;quot;:   &amp;quot;Terminator&amp;quot;,&#xA;&#x9;}&#xA;&#x9;writeToFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;w)&#xA;&#x9;r := make(map[string]string)&#xA;&#x9;readFromFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;r)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>chroot 脚本</title>
      <link>http://jouyouyun.github.io/Blog/chroot-%E8%84%9A%E6%9C%AC/</link>
      <pubDate>2014-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近测试了以下 &lt;code&gt;chroot&lt;/code&gt;，然后把步骤写成了下面两个脚本，方便以后使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Arch&lt;/code&gt; 分区结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/dev/sda5&#x9;/&#xA;/dev/sda1&#x9;/boot&#xA;/dev/sda6&#x9;/home&#xA;/dev/sda8&#x9;Swap&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt; 挂载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;_ROOT=/dev/sda5&#xA;_BOOT=/dev/sda1&#xA;#_HOME=/dev/sda6&#xA;&#xA;#创建目录结构&#xA;sudo mkdir -p /mnt/arch&#xA;sudo mkdir -p /mnt/arch/boot&#xA;#sudo mkdir -p /mnt/arch/home&#xA;&#xA;#挂载分区&#xA;sudo mount $_ROOT /mnt/arch&#xA;sudo mount $_BOOT /mnt/arch/boot&#xA;#sudo mount $_HOME /mnt/arch/home&#xA;&#xA;#挂载临时文件系统&#xA;cd /mnt/arch&#xA;sudo mount -t proc proc proc/&#xA;sudo mount -t sysfs sys sys/&#xA;sudo mount -o bind /dev dev/&#xA;sudo mount -t devpts pts dev/pts&#xA;&#xA;#如果你已经建立了一个网络连接并且想要在chroot环境中使用它，&#xA;#你可能不得不拷贝你的DNS服务器配置让你能够解析主机名&#xA;sudo  cp -L /etc/resolv.conf etc/resolv.conf&#xA;&#xA;# chroot 并指定 shell&#xA;sudo chroot /mnt/arch /usr/bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt;  卸载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;#在退出 chroot 后执行此脚本&#xA;&#xA;#卸载临时文件系统和已挂载的设备&#xA;#sudo umount {proc,sys,dev/pts,dev,boot,home}&#xA;sudo umount {proc,sys,dev/pts,dev,boot}&#xA;&#xA;#尝试卸载根分区&#xA;cd /&#xA;sudo umount /mnt/arch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在 VPS 中搭建 VPN 服务器</title>
      <link>http://jouyouyun.github.io/Blog/%E5%9C%A8-VPS-%E4%B8%AD%E6%90%AD%E5%BB%BA-VPN-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近 &lt;code&gt;Google&lt;/code&gt; 被封，而用 &lt;code&gt;Goagent&lt;/code&gt; 做代理进行访问的效果而不是很理想，所以就想去买 &lt;code&gt;VPN/VPS&lt;/code&gt;。几经考虑后，就去买了个便宜 &lt;code&gt;VPS&lt;/code&gt;，这样也就可以分享给家人用了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;VPS&lt;/code&gt; 中安装的是 &lt;code&gt;Ubuntu&lt;/code&gt;，所以搭建 &lt;code&gt;VPN&lt;/code&gt; 服务器也就是在 &lt;code&gt;Ubuntu&lt;/code&gt; 上面搭建，具体方法如下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：下面所有的操作都是以 &lt;code&gt;root&lt;/code&gt; 用户进行的，非 &lt;code&gt;root&lt;/code&gt; 用户请在命令前加上 &lt;code&gt;sudo&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;pptp&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;apt-get install pptpd&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置 &lt;code&gt;IP&lt;/code&gt; 地址范围及服务器 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/pptpd.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消下面内容的注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;option /etc/ppp/pptpd-options&#xA;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;添加用于登录的账户&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/chap-secrets&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;格式如下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;用户名    pptpd   &amp;quot;密码&amp;quot;    *&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;密码需要用英文双引号，最后的星号(*)代表允许接入的 &lt;code&gt;IP&lt;/code&gt; 可以是任意 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;设置 &lt;code&gt;DNS&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/pptpd-options&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;找到 &lt;code&gt;ms-dns&lt;/code&gt;，取消掉注释，并修改 &lt;code&gt;DNS&lt;/code&gt; 地址，推荐使用 &lt;code&gt;Google DNS&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; 8.8.8.8 &#xA; 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;打开内核 &lt;code&gt;IP&lt;/code&gt; 转发&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消以下内容的注释：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使其生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysctl -p&#xA;/etc/init.d/procps restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;iptables&lt;/code&gt; 并设置&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;开放主机防火墙 &lt;code&gt;VPN&lt;/code&gt; 端口（默认为 &lt;code&gt;1723&lt;/code&gt;）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables -I INPUT -p tcp --dport 1723 -j ACCEPT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;立刻让内核支持 &lt;code&gt;NAT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了让每次重启都生效，还需要在 &lt;code&gt;/etc/rc.local&lt;/code&gt; 文件添加命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;SSH` 代理&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;如要使用 &lt;code&gt;ssh&lt;/code&gt; 作为代理，则需要创建用户。若此用户只作为 &lt;code&gt;ssh&lt;/code&gt; 代理用，则不要登录 &lt;code&gt;shell&lt;/code&gt; 及主目录，使用以下命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;useradd -s /bin/false  test&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在客户端(&lt;code&gt;linux&lt;/code&gt;)中使用以下命令连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ssh -qTfnN -D 7070 test@xxx.xxx.xxx.xxx&lt;/code&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: md5 sum</title>
      <link>http://jouyouyun.github.io/Note/Go-%E7%AC%94%E8%AE%B0--md5-sum/</link>
      <pubDate>2014-06-22 10:54:38 +0800</pubDate>
      <description>&lt;p&gt;使用 Go 语言实现字符串与文件的 MD5 值计算，但是大文件不要使用此方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;crypto/md5&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;&#x9;MD5_STR_LEN = 32&#xA;)&#xA;&#xA;func md5ByteToStr(bytes [16]byte) string {&#xA;&#x9;str := &amp;quot;&amp;quot;&#xA;&#xA;&#x9;for _, b := range bytes {&#xA;&#x9;&#x9;s := strconv.FormatInt(int64(b), 16)&#xA;&#x9;&#x9;if len(s) == 1 {&#xA;&#x9;&#x9;&#x9;str += &amp;quot;0&amp;quot; + s&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;str += s&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return str&#xA;}&#xA;&#xA;func SumStrMd5(str string) (string, bool) {&#xA;&#x9;if len(str) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum([]byte(str))&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&#xA;func SumFileMd5(filename string) (string, bool) {&#xA;&#x9;if !IsFileExist(filename) {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum(contents)&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 判断文件是否存在</title>
      <link>http://jouyouyun.github.io/Note/Go-%E7%AC%94%E8%AE%B0--%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>2014-06-20 09:38:13 +0800</pubDate>
      <description>&lt;p&gt;使用 GoLang 判断文件是否存在。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func isFileExist(filename string) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;_, err := os.Stat(filename)&#xA;&#xA;&#x9;return err == nil || os.IsExist(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: URI Encode/Decode</title>
      <link>http://jouyouyun.github.io/Note/Go-%E7%AC%94%E8%AE%B0--URI-Encode%2FDecode/</link>
      <pubDate>2014-06-20 09:20:12 +0800</pubDate>
      <description>&lt;p&gt;最近在处理路径时，要求统一用 URI(通用资源标识符) 的格式来表示。偶尔会遇到 URI 被编码的情况，这就需要解码了，故在此把 Encode/Decode URI 的方法记录在此，以备后用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;net/url&amp;quot;&#xA;)&#xA;&#xA;/**&#xA; * Input: filepath&#xA; * Output: encode string&#xA; */&#xA;func encodeURI (filepath string) string {&#xA;&#x9;if len(filepath) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u := url.URL{}&#xA;&#x9;u.Path = filepath&#xA;&#x9;return u.String()&#xA;}&#xA;&#xA;/**&#xA; * Input: URI string&#xA; * Output: filepath&#xA; */&#xA;func decodeURI (uri string) string {&#xA;&#x9;if len(uri) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u, err := url.Parse(uri)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;return u.Path&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>XRecord 示例</title>
      <link>http://jouyouyun.github.io/Note/XRecord-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-04-18 05:42:15 +0800</pubDate>
      <description>&lt;p&gt;最近在做快捷键绑定的项目，但在绑定单按键时发现 &lt;code&gt;XGrabKey&lt;/code&gt; 无法处理。遂请教组长，得知 &lt;code&gt;XRecord&lt;/code&gt; 可以处理，于是就去查找 &lt;code&gt;XRecord&lt;/code&gt; 的相关资料，但却很少。&#xA;所以在此记录一下整理的示例代码，以便日后查看，其功能在代码注释中写出。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*&#xA; * XRecord 是 XLib 的一个扩展，在 xtst 中。&#xA; * 此程序用来监听按键、鼠标点击和鼠标移动事件&#xA; */&#xA;&#xA;#include &amp;lt;glib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlibint.h&amp;gt;&#xA;#include &amp;lt;X11/extensions/record.h&amp;gt;&#xA;&#xA;typedef struct _RecordEventInfo {&#xA;        Display *ctrl_disp; // 控制通道&#xA;        Display *data_disp; // 数据通道&#xA;        XRecordRange *range;&#xA;        XRecordContext context;&#xA;} RecordEventInfo;&#xA;&#xA;typedef union {&#xA;        unsigned char type; // 事件类型&#xA;        xEvent xe; // 事件&#xA;} RecordDate;&#xA;&#xA;static void record_init ();&#xA;static void record_finalize ();&#xA;static void record_event_cb (XPointer user_data, XRecordInterceptData *hook);&#xA;static gpointer enable_ctx_thread (gpointer user_data);&#xA;&#xA;GMainLoop *loop= NULL;&#xA;static RecordEventInfo *grab_info = NULL;&#xA;&#xA;static void&#xA;record_init ()&#xA;{&#xA;        grab_info = g_new0 (RecordEventInfo, 1);&#xA;&#xA;        if ( !grab_info ) {&#xA;                g_warning (&amp;quot;Alloc RecordEventInfo memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;ctrl_disp = XOpenDisplay (NULL);&#xA;        grab_info-&amp;gt;data_disp = XOpenDisplay (NULL);&#xA;&#xA;        if ( !grab_info-&amp;gt;ctrl_disp || !grab_info-&amp;gt;data_disp ) {&#xA;                g_warning (&amp;quot;Unable to connect to X server...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        gint dummy;&#xA;&#xA;        if ( !XQueryExtension (grab_info-&amp;gt;ctrl_disp, &amp;quot;XTEST&amp;quot;,&#xA;                                   &amp;amp;dummy, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;XTest extension missing...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        if ( !XRecordQueryVersion (grab_info-&amp;gt;ctrl_disp, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;Failed to obtain xrecord version...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;range = XRecordAllocRange ();&#xA;&#xA;        if ( !grab_info-&amp;gt;range ) {&#xA;                g_warning (&amp;quot;Alloc XRecordRange memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        // 定义需要监听的事件范围，具体见 XRecord 文档&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.first = KeyPress;&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.last = MotionNotify;&#xA;&#xA;        XRecordClientSpec spec = XRecordAllClients;&#xA;        grab_info-&amp;gt;context = XRecordCreateContext (&#xA;                                                grab_info-&amp;gt;data_disp,&#xA;                                                0, &amp;amp;spec, 1,&#xA;                                                &amp;amp;grab_info-&amp;gt;range, 1);&#xA;&#xA;        if ( !grab_info-&amp;gt;context ) {&#xA;                g_warning (&amp;quot;Unable to create context...&amp;quot;);&#xA;                record_finalize();&#xA;        }&#xA;&#xA;        XSynchronize (grab_info-&amp;gt;ctrl_disp, TRUE);&#xA;        XFlush (grab_info-&amp;gt;ctrl_disp);&#xA;&#xA;        // 创建线程来处理接收到的数据&#xA;        GThread *thrd = g_thread_new (&amp;quot;enable context&amp;quot;,&#xA;                                (GThreadFunc)enable_ctx_thread, NULL);&#xA;&#xA;        if ( !thrd ) {&#xA;                g_warning (&amp;quot;Unable to create thread...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;}&#xA;&#xA;/*&#xA; * 释放资源&#xA; */&#xA;&#xA;static void&#xA;record_finalize ()&#xA;{&#xA;        if (!grab_info) {&#xA;                return;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;context) {&#xA;                XRecordDisableContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;                XRecordFreeContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;range) {&#xA;                XFree(grab_info-&amp;gt;range);&#xA;                grab_info-&amp;gt;range = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;ctrl_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;ctrl_disp);&#xA;                grab_info-&amp;gt;ctrl_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;data_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;data_disp);&#xA;                grab_info-&amp;gt;data_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info) {&#xA;                g_free (grab_info);&#xA;                grab_info = NULL;&#xA;        }&#xA;}&#xA;&#xA;static gpointer&#xA;enable_ctx_thread (gpointer user_data)&#xA;{&#xA;        // 开始接收数据&#xA;        if ( !XRecordEnableContext (grab_info-&amp;gt;data_disp,&#xA;                                        grab_info-&amp;gt;context,&#xA;                                        record_event_cb, NULL) ) {&#xA;                g_warning (&amp;quot;Unable to enable context...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        g_thread_exit (NULL);&#xA;        g_main_loop_quit(loop);&#xA;&#xA;        return NULL;&#xA;}&#xA;&#xA;static void&#xA;record_event_cb (XPointer user_data, XRecordInterceptData *hook)&#xA;{&#xA;        if ( hook-&amp;gt;category != XRecordFromServer ) {&#xA;                XRecordFreeData(hook);&#xA;                g_warning (&amp;quot;Data not from X server...&amp;quot;);&#xA;                return;&#xA;        }&#xA;&#xA;        RecordDate *data = (RecordDate *)hook-&amp;gt;data;&#xA;        int detail = data-&amp;gt;xe.u.u.detail; // 按键或鼠标的 keycode&#xA;        int event_type = data-&amp;gt;type; // 事件类型&#xA;        // 事件发生时的坐标&#xA;        int rootX = data-&amp;gt;xe.u.keyButtonPointer.rootX;&#xA;        int rootY = data-&amp;gt;xe.u.keyButtonPointer.rootY;&#xA;        /*int time = hook-&amp;gt;server_time;*/&#xA;&#xA;        switch (event_type) {&#xA;        case KeyPress:&#xA;                g_print(&amp;quot;%d pressed\n&amp;quot;, detail);&#xA;                /*KeySym sym = XKeycodeToKeysym(grab_info-&amp;gt;data_disp, detail, 0);*/&#xA;                break;&#xA;&#xA;        case KeyRelease:&#xA;                g_print(&amp;quot;%d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case MotionNotify:&#xA;                g_print(&amp;quot;Mouse Motion: %d -- %d\n&amp;quot;, rootX, rootY);&#xA;                break;&#xA;&#xA;        case ButtonPress:&#xA;                g_print(&amp;quot;Mouse %d pressed\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case ButtonRelease:&#xA;                g_print(&amp;quot;Mouse %d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        default:&#xA;                break;&#xA;        }&#xA;&#xA;        XRecordFreeData(hook);&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        record_init();&#xA;&#xA;        loop = g_main_loop_new(NULL, FALSE);&#xA;        g_main_loop_run(loop);&#xA;        g_main_loop_unref(loop);&#xA;        record_finalize();&#xA;&#xA;        return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>