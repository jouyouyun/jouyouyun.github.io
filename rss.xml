<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Jouyouyun&#39;s Blog</title>
    <link>http://45.62.229.81:8080</link>
    <pubDate>03 Aug 16 20:38 CST</pubDate>
    <item>
      <title>xrandr examples</title>
      <link>http://45.62.229.81:8080/Blog/xrandr-examples/</link>
      <pubDate>2016-06-06 04:52:30 +0800</pubDate>
      <description>&lt;p&gt;由于经常会用到使用 &lt;code&gt;xrandr&lt;/code&gt; 设置屏幕属性, 而每次用的时候都要去查 &lt;code&gt;man&lt;/code&gt; 手册, 有时还需要上网搜索例子.&#xA;这样一来就比较麻烦, 所以就想整理下 &lt;code&gt;xrandr&lt;/code&gt; 的用法, 给出一些常用的例子.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;查询&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用 &lt;code&gt;xrandr -q&lt;/code&gt; 命令可以查询当前的显示器状态, 使用 &lt;code&gt;xrandr --verbose&lt;/code&gt; 将会显示更详细的信息.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置分辨率时需要指定设置的 &lt;code&gt;ouput&lt;/code&gt; 以及 &lt;code&gt;mode&lt;/code&gt;, 如将 &lt;code&gt;eDP1&lt;/code&gt; 的分辨率改为 &lt;code&gt;1920x1080&lt;/code&gt;, 命令就是 &lt;code&gt;xrandr --output eDP1 --mode 1920x1080&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是单屏时不用这么麻烦, 可以直接使用命令 &lt;code&gt;xrandr -s 1920x1080&lt;/code&gt; 来更改.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;添加分辨率&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果 &lt;code&gt;xrandr -q&lt;/code&gt; 查询的结果中没有合适的分辨率, 则可以通过 &lt;code&gt;newmode&lt;/code&gt; 来添加一个, 下面将给出为 &lt;code&gt;eDP1&lt;/code&gt; 添加 &lt;code&gt;1440x900x60&lt;/code&gt; 的分辨率的方法.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;cvt&lt;/code&gt; 生成一个 &lt;code&gt;modeline&lt;/code&gt;, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;cvt 1440 900 60&#xA;# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHz&#xA;Modeline &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;newmode&lt;/code&gt; 创建一个 &lt;code&gt;mode&lt;/code&gt;, 参数就是上面 &lt;code&gt;Modeline&lt;/code&gt; 后的内容, 命令如下:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;xrandr --newmode &amp;quot;1440x900_60.00&amp;quot;  106.50  1440 1528 1672 1904  900 903 909 934 -hsync +vsync&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;将上面的 &lt;code&gt;mode&lt;/code&gt; 添加到 &lt;code&gt;eDP1&lt;/code&gt; 中:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-&amp;gt;xrandr --addmode eDP1 1440x900_60.00&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果执行出错, 则说明不支持此模式. 如果没有错误则添加完成, 然后就可以设置此 &lt;code&gt;mode&lt;/code&gt; 为分辨率了.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;双屏配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如现在有两个 &lt;code&gt;output&lt;/code&gt;, 分别是 &lt;code&gt;eDP1&lt;/code&gt; 和 &lt;code&gt;VGA1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;设置主屏&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;通过指定 &lt;code&gt;--primary&lt;/code&gt; 参数来设置主屏, 如设置 &lt;code&gt;eDP1&lt;/code&gt; 为主屏: &lt;code&gt;xrandr --auto --output eDP1 --primary&lt;/code&gt;, &lt;code&gt;--auto&lt;/code&gt; 可以自动启用关闭的屏幕.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;复制模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;复制模式最好使用两个显示器都有的 &lt;code&gt;mode&lt;/code&gt; 作为默认的 &lt;code&gt;mode&lt;/code&gt;, 命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1440x900 --output VGA1 --same-as eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;扩展模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;命令是 &lt;code&gt;xrandr --auto --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --mode 1440x900 --right-of eDP1&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;命令的结果就是 &lt;code&gt;VGA1&lt;/code&gt; 会在 &lt;code&gt;eDP1&lt;/code&gt; 的右边, &lt;code&gt;eDP1&lt;/code&gt; 为主屏, 另外位置的参数还有 &lt;code&gt;left-of&lt;/code&gt;, &lt;code&gt;--above&lt;/code&gt;, &lt;code&gt;--below&lt;/code&gt; 等.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果需要自定义两个屏幕的位置, 可以通过计算每个屏幕的分辨率, 用 &lt;code&gt;--pos&lt;/code&gt; 参数来指定每个屏幕显示的位置.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;单屏模式&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这个模式是只显示某一个屏幕, 如只显示 &lt;code&gt;eDP1&lt;/code&gt;, 可以使用命令 &lt;code&gt;xrandr --output eDP1 --pos 0x0 --mode 1920x1080 --primary --output VGA1 --off&lt;/code&gt;,&#xA;这样就会把 &lt;code&gt;VGA1&lt;/code&gt; 给关闭.&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;其它&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;另外屏幕的旋转, 镜像和缩放可以分别使用 &lt;code&gt;--rotate&lt;/code&gt;, &lt;code&gt;reflect&lt;/code&gt; 和 &lt;code&gt;--scale&lt;/code&gt; 参数来实现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至于更详细的信息请使用 &lt;code&gt;man xrandr&lt;/code&gt; 来查看.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Enable coredump</title>
      <link>http://45.62.229.81:8080/Note/Enable-coredump/</link>
      <pubDate>2016-04-25 07:04:33 +0800</pubDate>
      <description>&lt;h2&gt;简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当一个程序崩溃时会产生一个 &lt;code&gt;core&lt;/code&gt; 文件, 里面记录了这个程序崩溃的原因, 这些信息对于开发者是很有用的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是 &lt;code&gt;core dumps&lt;/code&gt; 在大多数 &lt;code&gt;linux&lt;/code&gt; 上是被禁用的, 下面就介绍下如何开启这个功能.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;开启&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;ulimit -c&lt;/code&gt; 的输出知道此功能是否开启, 输出为 &lt;code&gt;0&lt;/code&gt; 表示禁用, 否则为开启.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;临时开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通过 &lt;code&gt;ulimit -c unlimited&lt;/code&gt; 命令来开启 &lt;code&gt;coredump&lt;/code&gt; 功能, 它会程序运行的当前目录生成一个 &lt;code&gt;core&lt;/code&gt; 文件, 新的 &lt;code&gt;core&lt;/code&gt; 会覆盖旧的.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过可以修改 &lt;code&gt;/proc/sys/kernel/core_uses_pid&lt;/code&gt; 文件内容为 &lt;code&gt;1&lt;/code&gt; 来生成以 &lt;code&gt;pid&lt;/code&gt; 作为扩展名的 &lt;code&gt;core&lt;/code&gt; 文件.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过修改 &lt;code&gt;/proc/sys/kernel/core_pattern&lt;/code&gt; 可以修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式. 如把内容改为 &lt;code&gt;/tmp/core-%e-%p-%t&lt;/code&gt;, 就表示把 &lt;code&gt;core&lt;/code&gt; 文件保存到 &lt;code&gt;/tmp&lt;/code&gt; 目录下, 文件名的格式为 &lt;code&gt;core-命令名-pid-时间戳&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;永久开启&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;首先把开启 &lt;code&gt;coredump&lt;/code&gt; 功能的命令 &lt;code&gt;ulimit -c unlimited &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 放到 &lt;code&gt;/etc/profile&lt;/code&gt; 中.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后修改 &lt;code&gt;core&lt;/code&gt; 文件的保存位置和格式, 在 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件中添加一下内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kernel.core_uses_pid = 1&#xA;kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改完 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 后, 执行 &lt;code&gt;sudo sysctl -p&lt;/code&gt; 重新加载配置.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;core pattern&lt;/code&gt; 说明:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;%% – A single % character&#xA;%p – PID of dumped process&#xA;%u – real UID of dumped process&#xA;%g – real GID of dumped process&#xA;%s – number of signal causing dump&#xA;%t – time of dump (seconds since 0:00h, 1 Jan 1970)&#xA;%h – hostname (same as ’nodename’ returned by uname(2))&#xA;%e – executable filename&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;参考&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.linuxreviews.org/HOWTO_enable_core-dumps&#34;&gt;HOWTO enable core-dumps&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cyberciti.biz/tips/linux-core-dumps.html&#34;&gt;HowTo: Debug Crashed Linux Application Core Files&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Auto Hidden Cursor</title>
      <link>http://45.62.229.81:8080/Blog/Auto-Hidden-Cursor/</link>
      <pubDate>2016-04-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近需要做一个隐藏光标的功能, 在这里将了解到的知识总结一下.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标的原理就是把光标设置为一个 &lt;code&gt;x11 null cursor&lt;/code&gt;, 不需要隐藏时再将它设为 &lt;code&gt;x11 left_ptr cursor&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;设置光标主要需要调用下面两个函数:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int XDefineCursor(Display *display, Window w, Cursor cursor);&#xA;void XFixesChangeCursorByName (Display *dpy, Cursor source, const char *name);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;创建光标&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;至于创建 &lt;code&gt;null cursor&lt;/code&gt; 可以见下面的代码:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;window = DefaultRootWindow(display);&#xA;Cursor invisibleCursor;&#xA;Pixmap bitmapNoData;&#xA;XColor black;&#xA;static char noData[] = { 0,0,0,0,0,0,0,0 };&#xA;black.red = black.green = black.blue = 0;&#xA;bitmapNoData = XCreateBitmapFromData(display, window, noData, 8, 8);&#xA;invisibleCursor = XCreatePixmapCursor(display, bitmapNoData, bitmapNoData, &amp;amp;black, &amp;amp;black, 0, 0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;创建完后, 将其设置为默认光标就可以了.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另外 &lt;code&gt;libxfixes&lt;/code&gt; 也提供了隐藏/显示光标的接口:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void XFixesHideCursor (Display *dpy, Window win);&#xA;void XFixesShowCursor (Display *dpy, Window win);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;其它&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;隐藏光标推荐使用 &lt;code&gt;unclutter&lt;/code&gt; 来设置, 它可以自定义空闲时间, 具体功能请见 &lt;code&gt;man&lt;/code&gt; 手册.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果使用 &lt;code&gt;lightdm&lt;/code&gt; 作为登录管理器, 可以编辑 &lt;code&gt;/etc/lightdm/lightdm.conf&lt;/code&gt; 文件,&#xA;在 &lt;code&gt;[Seat:*]&lt;/code&gt; 后添加 &lt;code&gt;xserver-command=X -bs -core -nocursor&lt;/code&gt;.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>debug 小结</title>
      <link>http://45.62.229.81:8080/Note/debug-%E5%B0%8F%E7%BB%93/</link>
      <pubDate>2016-02-03 03:06:35 +0800</pubDate>
      <description>&lt;p&gt;调试 &lt;code&gt;bug&lt;/code&gt; 的时候要有耐心, 要不断测试, 直到找到问题原因.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;确定 &lt;code&gt;bug&lt;/code&gt; 出现的方式&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一定要找到稳定重现的方式, 这样才能方便下面的调试&lt;/li&gt;&#xA;&lt;li&gt;如果找不到稳定重现的方法就只能根据上次出现的情形, 去查看相关的代码, 猜测可能出问题的地方, 然后针对那一块进行调试, 直到找到稳定重现方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;定位出问题的代码&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;再找到稳定重现方式后, 开始定位出问题的函数, 然后加入调试信息, 不断尝试, 直到找到有问题的代码&lt;/li&gt;&#xA;&lt;li&gt;找到有问题的代码后, 如果发现是第三方库里的函数,可以打印出每次调用的输入输出参数, 看看是否有迹可循, 可以单独写个小程序, 传入问题的参数, 进行不断测试, 来确定第三方库有没有问题&lt;/li&gt;&#xA;&lt;li&gt;如果自己程序的代码, 就一行一行的慢慢测试, 确定问题的原因, 原因找到了就可以开始思考解决方法了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;修复 &lt;code&gt;bug&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;修复 &lt;code&gt;bug&lt;/code&gt; 时一定要仔细检查新添加的代码, 看看会不会造成其它的 &lt;code&gt;bug&lt;/code&gt;, 一定要不断测试, 把函数输入输出状态都打印出来, 以免出现界面是对的, 但函数的数据有误.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于开源的第三方库有问题时, 就把它的代码下下来, 加上调试信息后, 然后安装, 让你的程序使用自己编译的第三方库, 这样方便查找问题.&#xA;因为有时可能第三方库再使用时需要初始化一些资源, 而你使用的接口并没有做或少做了一点, 这样就导致你的程序出了问题.&#xA;这时就可以在程序中添加相关的初始化代码, 来处理这类问题, 这类问题一般第三方库升级时可能出现.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;若知道问题的原因后(这个原因一定要是相关低层的, 不能说是由于 A 调了 B , B 出问题了, 就把问题原因归与 A 的头上, 一定要是相当精确的), 不知道怎么修改, 这时就可以向组内成员求助, 或者去了解这方面的知识.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;性能调试工具&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于 &lt;code&gt;C/C++&lt;/code&gt; 代码, 可以使用 &lt;code&gt;Google Proftools&lt;/code&gt; 工具来调试. 它以程序调用的方式生成每次调用的性能消耗图, 方便定位占用资源多的函数.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文档见: &lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/&#34;&gt;Google Proftools Documents&lt;/a&gt; , 使用方法自行 &lt;code&gt;google&lt;/code&gt; .&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;网站推荐&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;还可以去一些开发者网站提问:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.quora.com/&#34;&gt;国外的知乎: Quora&lt;/a&gt;&#xA;&lt;a href=&#34;http://segmentfault.com/&#34;&gt;SegmentFault&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者到 &lt;a href=&#34;http://www.ibm.com/developerworks/cn/&#34;&gt;IBM Developer&lt;/a&gt; 看写相关的技术文章, 前端的话还可以去 &lt;a href=&#34;https://developer.mozilla.org/&#34;&gt;Mozilla Developer&lt;/a&gt; .&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>xsetwacom 选项说明</title>
      <link>http://45.62.229.81:8080/Blog/xsetwacom-%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E/</link>
      <pubDate>2016-02-03 02:58:29 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;xsetwacom&lt;/code&gt; 是一个设置数位板的命令行工具, 在 &lt;code&gt;Debian/Ubuntu/deepin&lt;/code&gt; 上可以通过安装 &lt;code&gt;xserver-xorg-input-wacom&lt;/code&gt; 来获取它.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以通过 &lt;code&gt;man xsetwacom&lt;/code&gt; 看到它的帮助文档, 下面就简单说明下它的部份选项:&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;Options&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;Area&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 x2 y2,&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板可使用的区域&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Button&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: button-number [mapping]&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔按钮的功能，可自定义为组合键，详细使用方法见文档&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;MapToOutput&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: output&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位板与显示屏的映射，可以使用 &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;Head Number&lt;/code&gt;, &lt;code&gt;X11 geometry&lt;/code&gt; 三种方式设置&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;output: 如 &lt;code&gt;VGA1&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Head Number: 通过 &lt;code&gt;XRandR extension&lt;/code&gt; 得到的&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;X11 geometry: 格式如 &lt;code&gt;WIDTHxHEIGHT+X+Y&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Mode&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: Absolute|Relative&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: Absolute&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置笔模式。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Absolute: 模式时数位笔对应的是数位板或屏幕的真实位置&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Relative: 模式时数位笔就像是一个鼠标&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;PressureCurve&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: x1 y1 x2 y2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 0 0 100 100&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 压力曲线，(x1&lt;y1 x2&lt;y2) to &#34;soften&#34;，(x1&gt;y1 x2&amp;gt;y2) to &amp;ldquo;firmer&amp;rdquo;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;RawSample&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 20)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 4&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置数位笔原始采样率对应的窗口大小，不太清楚有什么用&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Rotate&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: none|half|cw|ccw&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: none&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置旋转度&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;none: 不旋转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;half: 上下翻转&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;cw: 顺时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;ccw: 逆时针旋转 90 度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Suppress&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 100)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 2&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置移动灵敏度，值越大灵敏度越低&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Touch&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许触摸&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;HWTouchSwitchState&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: on|off&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: on&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 是否允许调节 &lt;code&gt;Touch&lt;/code&gt; 选项&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Threshold&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;args: level(0 ~ 2047)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;default: 27&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;description: 设置产生按键事件的最小力度&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;h2&gt;其他&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;对于压力曲线，这里给出了一些测试值，从 &lt;code&gt;soften&lt;/code&gt; 到 &lt;code&gt;firmer&lt;/code&gt; :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0 100 0 100&lt;/li&gt;&#xA;&lt;li&gt;20 80 20 80&lt;/li&gt;&#xA;&lt;li&gt;30 70 30 70&lt;/li&gt;&#xA;&lt;li&gt;0 0 100 100&lt;/li&gt;&#xA;&lt;li&gt;60 40 60 40&lt;/li&gt;&#xA;&lt;li&gt;70 30 70 30&lt;/li&gt;&#xA;&lt;li&gt;75 25 75 25&lt;/li&gt;&#xA;&lt;li&gt;80 20 80 20&lt;/li&gt;&#xA;&lt;li&gt;90 10 90 10&lt;/li&gt;&#xA;&lt;li&gt;100 0 100 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 简单的 TCP Socket 示例</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--%E7%AE%80%E5%8D%95%E7%9A%84-TCP-Socket-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-07-20 12:54:43 +0800</pubDate>
      <description>&lt;p&gt;一个简单的 &lt;code&gt;TCP Socket&lt;/code&gt; 的示例，使用 &lt;code&gt;gob&lt;/code&gt; 处理传输的数据。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;server.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;const (&#xA;&#x9;BUF_SIZE = 1024&#xA;)&#xA;&#xA;func handleConnection(conn *net.TCPConn) {&#xA;&#x9;if conn == nil {&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;defer conn.Close()&#xA;&#xA;&#x9;data := make([]byte, BUF_SIZE)&#xA;&#x9;for {&#xA;&#x9;&#x9;n, err := conn.Read(data)&#xA;&#x9;&#x9;if err == io.EOF {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Read connection data failed:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Read %v byte data\n&amp;quot;, n)&#xA;&#xA;&#x9;&#x9;b := bytes.NewBuffer(data)&#xA;&#x9;&#x9;dec := gob.NewDecoder(b)&#xA;&#xA;&#x9;&#x9;info := personInfo{}&#xA;&#x9;&#x9;dec.Decode(&amp;amp;info)&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Server receive data: %v\n&amp;quot;, info)&#xA;&#x9;}&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;l, err := net.ListenTCP(&amp;quot;tcp&amp;quot;, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Listen port error:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;conn, err := l.AcceptTCP()&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;The client: %s connected\n&amp;quot;, conn.RemoteAddr().String())&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Println(&amp;quot;Accept error:&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;go handleConnection(conn)&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;client.go&lt;/code&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;net&amp;quot;&#xA;&#x9;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;type personInfo struct {&#xA;&#x9;Name  string&#xA;&#x9;Age   int32&#xA;&#x9;Phone string&#xA;&#x9;Addr  string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;tcpAddr, err := net.ResolveTCPAddr(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8087&amp;quot;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;ResolveTCPAddr failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;conn, err := net.DialTCP(&amp;quot;tcp&amp;quot;, nil, tcpAddr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;Create connection failed:&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;info := personInfo{&amp;quot;Maya&amp;quot;, 18, &amp;quot;13277085678&amp;quot;, &amp;quot;Hubei China&amp;quot;}&#xA;&#x9;var b bytes.Buffer&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;b)&#xA;&#x9;enc.Encode(&amp;amp;info)&#xA;&#x9;for {&#xA;&#x9;&#x9;conn.Write(b.Bytes())&#xA;&#x9;&#x9;fmt.Println(b.Bytes())&#xA;&#x9;&#x9;&amp;lt;-time.After(time.Second * 3)&#xA;&#x9;}&#xA;&#x9;conn.Close()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记：Gob Write/Read File</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0%EF%BC%9AGob-Write%2FRead-File/</link>
      <pubDate>2014-07-07 01:06:28 +0800</pubDate>
      <description>&lt;p&gt;&lt;code&gt;Gob&lt;/code&gt; 使用实例，将结构体写入文件里，在需要的时候再从文件中读取出来。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&amp;quot;bytes&amp;quot;&#xA;&#x9;&amp;quot;encoding/gob&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;type Writer struct {&#xA;&#x9;Id    int&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;type Reader struct {&#xA;&#x9;Name  string&#xA;&#x9;Value string&#xA;}&#xA;&#xA;func writeToFile(filename string, data interface{}) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;writeToFile filename invalid&amp;quot;)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;var w bytes.Buffer&#xA;&#xA;&#x9;enc := gob.NewEncoder(&amp;amp;w)&#xA;&#x9;if err := enc.Encode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Encode data error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;if fp, err := os.Create(filename); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Open &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return false&#xA;&#x9;} else {&#xA;&#x9;&#x9;defer fp.Close()&#xA;&#x9;&#x9;fp.WriteString(w.String())&#xA;&#x9;&#x9;fp.Sync()&#xA;&#x9;}&#xA;&#xA;&#x9;return true&#xA;}&#xA;&#xA;func readFromFile(filename string, data interface{}) {&#xA;&#x9;if len(filename) &amp;lt; 1 || data == nil {&#xA;&#x9;&#x9;fmt.Println(&amp;quot;readFromFile args invalid&amp;quot;)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;ReadFile &#39;%s&#39; error: %v\n&amp;quot;, filename, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;r := bytes.NewBuffer(contents)&#xA;&#x9;dec := gob.NewDecoder(r)&#xA;&#xA;&#x9;if err := dec.Decode(data); err != nil {&#xA;&#x9;&#x9;fmt.Printf(&amp;quot;Decode error: %v\n&amp;quot;, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;return&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;wData := Writer{0, &amp;quot;firefox&amp;quot;, &amp;quot;Web Broswer&amp;quot;}&#xA;&#xA;&#x9;writeToFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;wData)&#xA;&#xA;&#x9;rData := Reader{}&#xA;&#x9;readFromFile(&amp;quot;/tmp/w&amp;quot;, &amp;amp;rData)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, rData)&#xA;&#xA;&#x9;// test map&#xA;&#x9;w := map[string]string{&#xA;&#x9;&#x9;&amp;quot;sublime-text&amp;quot;: &amp;quot;Sublime Text&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;firefox&amp;quot;:      &amp;quot;Web Broswer&amp;quot;,&#xA;&#x9;&#x9;&amp;quot;terminator&amp;quot;:   &amp;quot;Terminator&amp;quot;,&#xA;&#x9;}&#xA;&#x9;writeToFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;w)&#xA;&#x9;r := make(map[string]string)&#xA;&#x9;readFromFile(&amp;quot;/tmp/map&amp;quot;, &amp;amp;r)&#xA;&#x9;fmt.Printf(&amp;quot;%v\n&amp;quot;, r)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>chroot 脚本</title>
      <link>http://45.62.229.81:8080/Blog/chroot-%E8%84%9A%E6%9C%AC/</link>
      <pubDate>2014-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近测试了以下 &lt;code&gt;chroot&lt;/code&gt;，然后把步骤写成了下面两个脚本，方便以后使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Arch&lt;/code&gt; 分区结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/dev/sda5&#x9;/&#xA;/dev/sda1&#x9;/boot&#xA;/dev/sda6&#x9;/home&#xA;/dev/sda8&#x9;Swap&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt; 挂载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;_ROOT=/dev/sda5&#xA;_BOOT=/dev/sda1&#xA;#_HOME=/dev/sda6&#xA;&#xA;#创建目录结构&#xA;sudo mkdir -p /mnt/arch&#xA;sudo mkdir -p /mnt/arch/boot&#xA;#sudo mkdir -p /mnt/arch/home&#xA;&#xA;#挂载分区&#xA;sudo mount $_ROOT /mnt/arch&#xA;sudo mount $_BOOT /mnt/arch/boot&#xA;#sudo mount $_HOME /mnt/arch/home&#xA;&#xA;#挂载临时文件系统&#xA;cd /mnt/arch&#xA;sudo mount -t proc proc proc/&#xA;sudo mount -t sysfs sys sys/&#xA;sudo mount -o bind /dev dev/&#xA;sudo mount -t devpts pts dev/pts&#xA;&#xA;#如果你已经建立了一个网络连接并且想要在chroot环境中使用它，&#xA;#你可能不得不拷贝你的DNS服务器配置让你能够解析主机名&#xA;sudo  cp -L /etc/resolv.conf etc/resolv.conf&#xA;&#xA;# chroot 并指定 shell&#xA;sudo chroot /mnt/arch /usr/bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;code&gt;chroot&lt;/code&gt;  卸载脚本&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;#在退出 chroot 后执行此脚本&#xA;&#xA;#卸载临时文件系统和已挂载的设备&#xA;#sudo umount {proc,sys,dev/pts,dev,boot,home}&#xA;sudo umount {proc,sys,dev/pts,dev,boot}&#xA;&#xA;#尝试卸载根分区&#xA;cd /&#xA;sudo umount /mnt/arch&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在 VPS 中搭建 VPN 服务器</title>
      <link>http://45.62.229.81:8080/Blog/%E5%9C%A8-VPS-%E4%B8%AD%E6%90%AD%E5%BB%BA-VPN-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>2014-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近 &lt;code&gt;Google&lt;/code&gt; 被封，而用 &lt;code&gt;Goagent&lt;/code&gt; 做代理进行访问的效果而不是很理想，所以就想去买 &lt;code&gt;VPN/VPS&lt;/code&gt;。几经考虑后，就去买了个便宜 &lt;code&gt;VPS&lt;/code&gt;，这样也就可以分享给家人用了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;VPS&lt;/code&gt; 中安装的是 &lt;code&gt;Ubuntu&lt;/code&gt;，所以搭建 &lt;code&gt;VPN&lt;/code&gt; 服务器也就是在 &lt;code&gt;Ubuntu&lt;/code&gt; 上面搭建，具体方法如下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：下面所有的操作都是以 &lt;code&gt;root&lt;/code&gt; 用户进行的，非 &lt;code&gt;root&lt;/code&gt; 用户请在命令前加上 &lt;code&gt;sudo&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;pptp&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;apt-get install pptpd&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置 &lt;code&gt;IP&lt;/code&gt; 地址范围及服务器 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/pptpd.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消下面内容的注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;option /etc/ppp/pptpd-options&#xA;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;添加用于登录的账户&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/chap-secrets&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;格式如下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;用户名    pptpd   &amp;quot;密码&amp;quot;    *&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;密码需要用英文双引号，最后的星号(*)代表允许接入的 &lt;code&gt;IP&lt;/code&gt; 可以是任意 &lt;code&gt;IP&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;设置 &lt;code&gt;DNS&lt;/code&gt;&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/ppp/pptpd-options&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;找到 &lt;code&gt;ms-dns&lt;/code&gt;，取消掉注释，并修改 &lt;code&gt;DNS&lt;/code&gt; 地址，推荐使用 &lt;code&gt;Google DNS&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; 8.8.8.8 &#xA; 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;打开内核 &lt;code&gt;IP&lt;/code&gt; 转发&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;vi /etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取消以下内容的注释：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使其生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sysctl -p&#xA;/etc/init.d/procps restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;安装 &lt;code&gt;iptables&lt;/code&gt; 并设置&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;开放主机防火墙 &lt;code&gt;VPN&lt;/code&gt; 端口（默认为 &lt;code&gt;1723&lt;/code&gt;）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables -I INPUT -p tcp --dport 1723 -j ACCEPT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;立刻让内核支持 &lt;code&gt;NAT&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了让每次重启都生效，还需要在 &lt;code&gt;/etc/rc.local&lt;/code&gt; 文件添加命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;iptables --table nat --append POSTROUTING --jump MASQUERADE&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;SSH` 代理&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;如要使用 &lt;code&gt;ssh&lt;/code&gt; 作为代理，则需要创建用户。若此用户只作为 &lt;code&gt;ssh&lt;/code&gt; 代理用，则不要登录 &lt;code&gt;shell&lt;/code&gt; 及主目录，使用以下命令&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;useradd -s /bin/false  test&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在客户端(&lt;code&gt;linux&lt;/code&gt;)中使用以下命令连接&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;ssh -qTfnN -D 7070 test@xxx.xxx.xxx.xxx&lt;/code&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: md5 sum</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--md5-sum/</link>
      <pubDate>2014-06-22 10:54:38 +0800</pubDate>
      <description>&lt;p&gt;使用 Go 语言实现字符串与文件的 MD5 值计算，但是大文件不要使用此方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;crypto/md5&amp;quot;&#xA;&#x9;&amp;quot;io/ioutil&amp;quot;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;&#x9;MD5_STR_LEN = 32&#xA;)&#xA;&#xA;func md5ByteToStr(bytes [16]byte) string {&#xA;&#x9;str := &amp;quot;&amp;quot;&#xA;&#xA;&#x9;for _, b := range bytes {&#xA;&#x9;&#x9;s := strconv.FormatInt(int64(b), 16)&#xA;&#x9;&#x9;if len(s) == 1 {&#xA;&#x9;&#x9;&#x9;str += &amp;quot;0&amp;quot; + s&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;str += s&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return str&#xA;}&#xA;&#xA;func SumStrMd5(str string) (string, bool) {&#xA;&#x9;if len(str) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum([]byte(str))&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&#xA;func SumFileMd5(filename string) (string, bool) {&#xA;&#x9;if !IsFileExist(filename) {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;contents, err := ioutil.ReadFile(filename)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;md5Byte := md5.Sum(contents)&#xA;&#x9;md5Str := md5ByteToStr(md5Byte)&#xA;&#x9;if len(md5Str) &amp;lt; MD5_STR_LEN {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, false&#xA;&#x9;}&#xA;&#xA;&#x9;return md5Str, true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: 判断文件是否存在</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</link>
      <pubDate>2014-06-20 09:38:13 +0800</pubDate>
      <description>&lt;p&gt;使用 GoLang 判断文件是否存在。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;os&amp;quot;&#xA;)&#xA;&#xA;func isFileExist(filename string) bool {&#xA;&#x9;if len(filename) &amp;lt; 1 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;_, err := os.Stat(filename)&#xA;&#xA;&#x9;return err == nil || os.IsExist(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go 笔记: URI Encode/Decode</title>
      <link>http://45.62.229.81:8080/Note/Go-%E7%AC%94%E8%AE%B0--URI-Encode%2FDecode/</link>
      <pubDate>2014-06-20 09:20:12 +0800</pubDate>
      <description>&lt;p&gt;最近在处理路径时，要求统一用 URI(通用资源标识符) 的格式来表示。偶尔会遇到 URI 被编码的情况，这就需要解码了，故在此把 Encode/Decode URI 的方法记录在此，以备后用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package utils&#xA;&#xA;import (&#xA;&#x9;&amp;quot;net/url&amp;quot;&#xA;)&#xA;&#xA;/**&#xA; * Input: filepath&#xA; * Output: encode string&#xA; */&#xA;func encodeURI (filepath string) string {&#xA;&#x9;if len(filepath) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u := url.URL{}&#xA;&#x9;u.Path = filepath&#xA;&#x9;return u.String()&#xA;}&#xA;&#xA;/**&#xA; * Input: URI string&#xA; * Output: filepath&#xA; */&#xA;func decodeURI (uri string) string {&#xA;&#x9;if len(uri) &amp;lt; 1 {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;u, err := url.Parse(uri)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;&#xA;&#x9;}&#xA;&#xA;&#x9;return u.Path&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>XRecord 示例</title>
      <link>http://45.62.229.81:8080/Note/XRecord-%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>2014-04-18 05:42:15 +0800</pubDate>
      <description>&lt;p&gt;最近在做快捷键绑定的项目，但在绑定单按键时发现 &lt;code&gt;XGrabKey&lt;/code&gt; 无法处理。遂请教组长，得知 &lt;code&gt;XRecord&lt;/code&gt; 可以处理，于是就去查找 &lt;code&gt;XRecord&lt;/code&gt; 的相关资料，但却很少。&#xA;所以在此记录一下整理的示例代码，以便日后查看，其功能在代码注释中写出。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*&#xA; * XRecord 是 XLib 的一个扩展，在 xtst 中。&#xA; * 此程序用来监听按键、鼠标点击和鼠标移动事件&#xA; */&#xA;&#xA;#include &amp;lt;glib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlib.h&amp;gt;&#xA;#include &amp;lt;X11/Xlibint.h&amp;gt;&#xA;#include &amp;lt;X11/extensions/record.h&amp;gt;&#xA;&#xA;typedef struct _RecordEventInfo {&#xA;        Display *ctrl_disp; // 控制通道&#xA;        Display *data_disp; // 数据通道&#xA;        XRecordRange *range;&#xA;        XRecordContext context;&#xA;} RecordEventInfo;&#xA;&#xA;typedef union {&#xA;        unsigned char type; // 事件类型&#xA;        xEvent xe; // 事件&#xA;} RecordDate;&#xA;&#xA;static void record_init ();&#xA;static void record_finalize ();&#xA;static void record_event_cb (XPointer user_data, XRecordInterceptData *hook);&#xA;static gpointer enable_ctx_thread (gpointer user_data);&#xA;&#xA;GMainLoop *loop= NULL;&#xA;static RecordEventInfo *grab_info = NULL;&#xA;&#xA;static void&#xA;record_init ()&#xA;{&#xA;        grab_info = g_new0 (RecordEventInfo, 1);&#xA;&#xA;        if ( !grab_info ) {&#xA;                g_warning (&amp;quot;Alloc RecordEventInfo memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;ctrl_disp = XOpenDisplay (NULL);&#xA;        grab_info-&amp;gt;data_disp = XOpenDisplay (NULL);&#xA;&#xA;        if ( !grab_info-&amp;gt;ctrl_disp || !grab_info-&amp;gt;data_disp ) {&#xA;                g_warning (&amp;quot;Unable to connect to X server...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        gint dummy;&#xA;&#xA;        if ( !XQueryExtension (grab_info-&amp;gt;ctrl_disp, &amp;quot;XTEST&amp;quot;,&#xA;                                   &amp;amp;dummy, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;XTest extension missing...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        if ( !XRecordQueryVersion (grab_info-&amp;gt;ctrl_disp, &amp;amp;dummy, &amp;amp;dummy) ) {&#xA;                g_warning (&amp;quot;Failed to obtain xrecord version...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        grab_info-&amp;gt;range = XRecordAllocRange ();&#xA;&#xA;        if ( !grab_info-&amp;gt;range ) {&#xA;                g_warning (&amp;quot;Alloc XRecordRange memory failed...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        // 定义需要监听的事件范围，具体见 XRecord 文档&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.first = KeyPress;&#xA;        grab_info-&amp;gt;range-&amp;gt;device_events.last = MotionNotify;&#xA;&#xA;        XRecordClientSpec spec = XRecordAllClients;&#xA;        grab_info-&amp;gt;context = XRecordCreateContext (&#xA;                                                grab_info-&amp;gt;data_disp,&#xA;                                                0, &amp;amp;spec, 1,&#xA;                                                &amp;amp;grab_info-&amp;gt;range, 1);&#xA;&#xA;        if ( !grab_info-&amp;gt;context ) {&#xA;                g_warning (&amp;quot;Unable to create context...&amp;quot;);&#xA;                record_finalize();&#xA;        }&#xA;&#xA;        XSynchronize (grab_info-&amp;gt;ctrl_disp, TRUE);&#xA;        XFlush (grab_info-&amp;gt;ctrl_disp);&#xA;&#xA;        // 创建线程来处理接收到的数据&#xA;        GThread *thrd = g_thread_new (&amp;quot;enable context&amp;quot;,&#xA;                                (GThreadFunc)enable_ctx_thread, NULL);&#xA;&#xA;        if ( !thrd ) {&#xA;                g_warning (&amp;quot;Unable to create thread...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;}&#xA;&#xA;/*&#xA; * 释放资源&#xA; */&#xA;&#xA;static void&#xA;record_finalize ()&#xA;{&#xA;        if (!grab_info) {&#xA;                return;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;context) {&#xA;                XRecordDisableContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;                XRecordFreeContext(grab_info-&amp;gt;data_disp, grab_info-&amp;gt;context);&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;range) {&#xA;                XFree(grab_info-&amp;gt;range);&#xA;                grab_info-&amp;gt;range = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;ctrl_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;ctrl_disp);&#xA;                grab_info-&amp;gt;ctrl_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info-&amp;gt;data_disp) {&#xA;                XCloseDisplay (grab_info-&amp;gt;data_disp);&#xA;                grab_info-&amp;gt;data_disp = NULL;&#xA;        }&#xA;&#xA;        if (grab_info) {&#xA;                g_free (grab_info);&#xA;                grab_info = NULL;&#xA;        }&#xA;}&#xA;&#xA;static gpointer&#xA;enable_ctx_thread (gpointer user_data)&#xA;{&#xA;        // 开始接收数据&#xA;        if ( !XRecordEnableContext (grab_info-&amp;gt;data_disp,&#xA;                                        grab_info-&amp;gt;context,&#xA;                                        record_event_cb, NULL) ) {&#xA;                g_warning (&amp;quot;Unable to enable context...&amp;quot;);&#xA;                record_finalize ();&#xA;        }&#xA;&#xA;        g_thread_exit (NULL);&#xA;        g_main_loop_quit(loop);&#xA;&#xA;        return NULL;&#xA;}&#xA;&#xA;static void&#xA;record_event_cb (XPointer user_data, XRecordInterceptData *hook)&#xA;{&#xA;        if ( hook-&amp;gt;category != XRecordFromServer ) {&#xA;                XRecordFreeData(hook);&#xA;                g_warning (&amp;quot;Data not from X server...&amp;quot;);&#xA;                return;&#xA;        }&#xA;&#xA;        RecordDate *data = (RecordDate *)hook-&amp;gt;data;&#xA;        int detail = data-&amp;gt;xe.u.u.detail; // 按键或鼠标的 keycode&#xA;        int event_type = data-&amp;gt;type; // 事件类型&#xA;        // 事件发生时的坐标&#xA;        int rootX = data-&amp;gt;xe.u.keyButtonPointer.rootX;&#xA;        int rootY = data-&amp;gt;xe.u.keyButtonPointer.rootY;&#xA;        /*int time = hook-&amp;gt;server_time;*/&#xA;&#xA;        switch (event_type) {&#xA;        case KeyPress:&#xA;                g_print(&amp;quot;%d pressed\n&amp;quot;, detail);&#xA;                /*KeySym sym = XKeycodeToKeysym(grab_info-&amp;gt;data_disp, detail, 0);*/&#xA;                break;&#xA;&#xA;        case KeyRelease:&#xA;                g_print(&amp;quot;%d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case MotionNotify:&#xA;                g_print(&amp;quot;Mouse Motion: %d -- %d\n&amp;quot;, rootX, rootY);&#xA;                break;&#xA;&#xA;        case ButtonPress:&#xA;                g_print(&amp;quot;Mouse %d pressed\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        case ButtonRelease:&#xA;                g_print(&amp;quot;Mouse %d released\n&amp;quot;, detail);&#xA;                break;&#xA;&#xA;        default:&#xA;                break;&#xA;        }&#xA;&#xA;        XRecordFreeData(hook);&#xA;}&#xA;&#xA;int&#xA;main(int argc, char *argv[])&#xA;{&#xA;        record_init();&#xA;&#xA;        loop = g_main_loop_new(NULL, FALSE);&#xA;        g_main_loop_run(loop);&#xA;        g_main_loop_unref(loop);&#xA;        record_finalize();&#xA;&#xA;        return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>